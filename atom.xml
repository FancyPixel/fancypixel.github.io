<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Fancy Pixel]]></title>
  <link href="http://fancypixel.github.io/atom.xml" rel="self"/>
  <link href="http://fancypixel.github.io/"/>
  <updated>2015-09-21T09:34:10+02:00</updated>
  <id>http://fancypixel.github.io/</id>
  <author>
    <name><![CDATA[Fancy Pixel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Playing with UIDynamics in iOS 9]]></title>
    <link href="http://fancypixel.github.io/blog/2015/06/19/playing-with-uidynamics-in-ios-9/"/>
    <updated>2015-06-19T12:35:31+02:00</updated>
    <id>http://fancypixel.github.io/blog/2015/06/19/playing-with-uidynamics-in-ios-9</id>
    <content type="html"><![CDATA[<p>UIDynamics was a welcome addition to the iOS 7 SDK. It&rsquo;s basically a physics engine backing common UIViews, allowing us to define physics traits to the UI elements. The API is fairly straightforward, so you can easily create animations and transitions that look and feel great. I already covered the basics in <a href="http://andreamazz.github.io/blog/2014/05/22/uikit-dynamics/">this article</a> a while ago, this time we&rsquo;ll be looking at what&rsquo;s new in UIDynamics in iOS 9.</p>

<!-- More -->


<h2>Collision Bounds</h2>

<p>The first release of UIDynamics shipped with a collision system (provided by <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollisionBehavior_Class/">UICollisionBehavior</a>) that only supported rectangular bodies. It made sense, since <code>UIView</code>s are backed by rectangular frames, but it&rsquo;s not uncommon to have a circular view, or even better our own custom Bezier path. With iOS 9 a new property has been added to the <code>UIDynamicItem</code> protocol: <code>UIDynamicItemCollisionBoundsType</code>, which accepts one of these enum values:</p>

<ul>
<li><code>Rectangle</code></li>
<li><code>Ellipse</code></li>
<li><code>Path</code></li>
</ul>


<p>The property is readonly, so if we want to change it we need to provide our own subclass:</p>

<pre><code class="swift">class Ellipse: UIView {
  override var collisionBoundsType: UIDynamicItemCollisionBoundsType {
    return .Ellipse
  }
}
</code></pre>

<p>This is a UIView with the default collision bound:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-06-19/slide.gif" width="500" title="'Slide'" ></p>

<p>This is the same UIView with the <code>.Ellipse</code>:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-06-19/roll.gif" width="500" title="'Roll'" ></p>

<p>This covers round views, if we want to get fancy and draw a more complex view with a coherent rigid body we can use the enum property <code>.Path</code> and also override this property:</p>

<pre><code class="swift">var collisionBoundingPath: UIBezierPath { get }
</code></pre>

<p>The path can be whatever you can think of, as long as it&rsquo;s convex (this means that for any given couple of points inside the polygon, the segment between the two is always entirely contained in the polygon itself) and counter-clockwise wound.<br/>
The convex requirement could be a significant limit, so <code>UIDynamicItemGroup</code> was introduced to specify shapes as a group of different shapes. This way as long as each shape in the group is convex we are fine even if the resulting polygon composition is concave.</p>

<h2>Field Behavior</h2>

<p>Field behaviors are a new type of behavior that is applied to the whole scene. The most common example that we&rsquo;ve been using implicitly all along is <code>UIGravityBehavior</code>, which applies a down force to each item in the scene. Now we can use a new set of field forces, like Radial (the forces are stronger at the center and weaker around the edges), Noise (forces with different magnitudes are scattered around the field), and so on.</p>

<h2>Dynamic Item Behavior</h2>

<p><code>UIDynamicItemBehavior</code> received a couple of interesting new properties:</p>

<pre><code class="ruby">var charge: CGFloat
var anchored: Bool
</code></pre>

<p><code>charge</code> represent the <em>electric charge</em> that can influence how an item moves in an electric or magnetic field (yeah, it&rsquo;s bonkers), while <code>anchored</code> basically turns a shape into a static object that participates in the collisions, but without response (if something crashes into the item, it won&rsquo;t budge), so it&rsquo;s perfect to represent something like a floor or a wall.</p>

<h2>Attachment Behavior</h2>

<p><code>UIAttachmentBehavior</code> was revamped and now has a sleuth of new methods and properties, like <code>frictionTorque</code> and <code>attachmentRange</code>. The attachments can now be more flexible, we can specify relative sliding movements, fixed attachments, rope attachments and what I like the most: pin attachment. Think of two objects nailed together and you get the idea.</p>

<p>This more or less covers what&rsquo;s new in UIDynamics, now it&rsquo;s time to drop the changelog and start building something silly.</p>

<h1>Let&rsquo;s play ball</h1>

<p>I&rsquo;ve been spending a lot of idle time with <a href="https://itunes.apple.com/us/app/ball-king/id946496840?mt=8">Ball King</a> in the last week. It&rsquo;s a brilliant little time waster, the concept is simple but well executed. Also it adopts the same monetization policies of the Apple design winner Crossy Road: it doesn&rsquo;t bother the player in any way. Kudos.</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-06-19/ballking.jpeg" width="322" height="572" title="'Ball King'" ></p>

<p>One thing I really like about it is the physic model of the ball and how the hoop&rsquo;s backboard reacts when it gets hit by it. Looks like a fun exercise to test out the new UIDynamics stuff listed above. Let&rsquo;s take a step by step look at how to build our own scruffy version: <a href="https://github.com/FancyPixel/BallSwift">BallSwift</a></p>

<h2>The hoop</h2>

<p>The basket can be created with a single UIView acting as the backboard, a couple of views with rigid bodies as the left and right arms of the hoop, and a frontmost view as the hoop itself (without a physic body). Using the previously defined class <code>Ellipse</code> we can create the visual representation of our game scene:</p>

<pre><code class="swift">/* 
Build the hoop, setup the world appearance
*/
func buildViews() {
  board = UIView(frame: CGRect(x: hoopPosition.x, y: hoopPosition.y, width: 100, height: 100))
  board.backgroundColor = .whiteColor()
  board.layer.borderColor = UIColor(red: 0.98, green: 0.98, blue: 0.98, alpha: 1).CGColor
  board.layer.borderWidth = 2

  board.addSubview({
    let v = UIView(frame: CGRect(x: 30, y: 43, width: 40, height: 40))
    v.backgroundColor = .clearColor()
    v.layer.borderColor = UIColor(red: 0.4, green: 0.4, blue: 0.4, alpha: 1).CGColor
    v.layer.borderWidth = 5
    return v
    }())

  leftHoop = Ellipse(frame: CGRect(x: hoopPosition.x + 20, y: hoopPosition.y + 80, width: 10, height: 6))
  leftHoop.backgroundColor = .clearColor()
  leftHoop.layer.cornerRadius = 3

  rightHoop = Ellipse(frame: CGRect(x: hoopPosition.x + 70, y: hoopPosition.y + 80, width: 10, height: 6))
  rightHoop.backgroundColor = .clearColor()
  rightHoop.layer.cornerRadius = 3

  hoop = UIView(frame: CGRect(x: hoopPosition.x + 20, y: hoopPosition.y + 80, width: 60, height: 6))
  hoop.backgroundColor = UIColor(red: 177.0/255.0, green: 25.0/255.0, blue: 25.0/255.0, alpha: 1)
  hoop.layer.cornerRadius = 3

  [board, leftHoop, rightHoop, floor, ball, hoop].map({self.view.addSubview($0)})
}
</code></pre>

<p>Nothing new here, the hoop is created programmatically and is placed in the constant <code>CGPoint hoopPosition</code>. The order of the views is important though, since we want the hoop to be above the basket ball.</p>

<h2>Nuts and bolts</h2>

<p>The most important part of the hoop are the left and right <em>arms</em>. They need a physical round body (so that the collision with the ball is smooth) and need to be bolted to the board and the front hoop. These two will be basic <code>UIDynamicItem</code>s and won&rsquo;t partecipate directly in the collisions. The newly introduced pin attachment is perfect for this job, it can hold everything together quite nicely as we can see in this rather ugly drawing:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-06-19/hoop.png" width="600" height="400" title="'Hoop'" ></p>

<p>The pin can be attached only to a couple of views at a time, within a given absolute spatial point:</p>

<pre><code class="swift">let bolts = [
  CGPoint(x: hoopPosition.x + 25, y: hoopPosition.y + 85), // leftHoop -&gt; Board
  CGPoint(x: hoopPosition.x + 75, y: hoopPosition.y + 85), // rightHoop -&gt; Board
  CGPoint(x: hoopPosition.x + 25, y: hoopPosition.y + 85), // hoop -&gt; Board (L)
  CGPoint(x: hoopPosition.x + 75, y: hoopPosition.y + 85)] // hoop -&gt; Board (R)

// Build the board
zip([leftHoop, rightHoop, hoop, hoop], offsets).map({
  (item, offset) in
  animator?.addBehavior(UIAttachmentBehavior.pinAttachmentWithItem(item, attachedToItem: board, attachmentAnchor: bolts))
})
</code></pre>

<p>If you&rsquo;re not participating in the race to Swift&rsquo;s functional awesomeness you&rsquo;re probably not familiar with zip and map. It might seem contrived at first, but it&rsquo;s rather simple: each view is coupled with the offset point in which we&rsquo;re going to pin the attachment, resulting in an array of tuples that is then used in the map function that, as the name suggests, creates a mapping with each element of the array with the provided closure. This results in both the left and right arms of the hoop to be bolted to the board and the front hoop as follows:</p>

<ul>
<li>Left arm bolted to the left of the board</li>
<li>Right arm bolted to the right of the board</li>
<li>Hoop bolted to the left of the board</li>
<li>Hoop bolted to the left of the board</li>
</ul>


<p>The next step requires us to <em>hang</em> the board, letting it rest loosely, so that a collision can cause it to swivel a bit like it does in Ball King:</p>

<pre><code class="swift">// Set the density of the hoop, and fix its angle
// Hang the hoop
animator?.addBehavior({
  let attachment = UIAttachmentBehavior(item: board, attachedToAnchor: CGPoint(x: hoopPosition.x, y: hoopPosition.y))
  attachment.length = 2
  attachment.damping = 5
  return attachment
  }())

animator?.addBehavior({
  let behavior = UIDynamicItemBehavior(items: [leftHoop, rightHoop])
  behavior.density = 10
  behavior.allowsRotation = false
  return behavior
  }())

// Block the board rotation
animator?.addBehavior({
  let behavior = UIDynamicItemBehavior(items: [board])
  behavior.allowsRotation = false
  return behavior
  }())
</code></pre>

<p>The hoop is ready to go. Let&rsquo;s take care of the ball, starting with a custom subclass of <code>UIImageView</code> with a rounded physics body, just like the <code>Ellipse</code> class:</p>

<pre><code class="swift">class Ball: UIImageView {
  override var collisionBoundsType: UIDynamicItemCollisionBoundsType {
    return .Ellipse
  }
}
</code></pre>

<p>We can then istantiate the ball as a common UIImageView:</p>

<pre><code class="swift">let ball: Ball = {
  let ball = Ball(frame: CGRect(x: 0, y: 0, width: 28, height: 28))
  ball.image = UIImage(named: "ball")
  return ball
}()
</code></pre>

<p>Finally we set its physical properties:</p>

<pre><code class="swift">// Set the elasticity and density of the ball
animator?.addBehavior({
  let behavior = UIDynamicItemBehavior(items: [ball])
  behavior.elasticity = 1
  behavior.density = 3
  behavior.action = {
    if !CGRectIntersectsRect(self.ball.frame, self.view.frame) {
      self.setupBehaviors()
      self.ball.center = CGPoint(x: 40, y: self.view.frame.size.height - 100)
    }
  }
  return behavior
  }())
</code></pre>

<p>In this bit of code I set the elasticity (how much it should bounce after a collision), density (think of it as the <em>weight</em>) and a handy action closure that resets the world state when the ball exits the play area (the main view).</p>

<h2>Collisions and gravity</h2>

<p>I mentioned the new <code>anchored</code> property of <code>UIDynamicItemBehavior</code>, which disables the dynamic behavior of an object while keeping it in the collision&rsquo;s loop. Sounds like a great way to build a steady floor:</p>

<pre><code class="swift">// Anchor the floor
animator?.addBehavior({
  let behavior = UIDynamicItemBehavior(items: [floor])
  behavior.anchored = true
  return behavior
  }())
</code></pre>

<p>Forget to set this property and you&rsquo;ll be scratching your head a lot. I know I did.<br/>
Ok, everything is set, it just needs some gravity and a set of collisions:</p>

<pre><code class="swift">animator?.addBehavior(UICollisionBehavior(items: [leftHoop, rightHoop, floor, ball]))
animator?.addBehavior(UIGravityBehavior(items: [ball]))
</code></pre>

<p>The gravity is a field behavior that applies a down force of 1 point per second as default. The collision behavior takes as parameter only the views that should collide with each other. The world is set up, now we can apply an instantaneous force to the ball and keep our fingers crossed:</p>

<pre><code class="swift">let push = UIPushBehavior(items: [ball], mode: .Instantaneous)
push.angle = -1.35
push.magnitude = 1.56
animator?.addBehavior(push)
</code></pre>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-06-19/ball.gif" width="500" height="820" title="'BallSwift'" ></p>

<p>And there you go, it&rsquo;s really rough around the edges, but that was a lot of fun to build (yes, the clouds and the bushes are the same drawing, like in <a href="https://www.youtube.com/watch?v=ai7d1K4Yf6A">Super Mario</a>).<br/>
As always you can find the source on our <a href="https://github.com/FancyPixel/BallSwift">GitHub page</a>.</p>

<p>Until next time,</p>

<p>Andrea - <em><a href="https://twitter.com/theandreamazz">@theandreamazz</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9 notifications and Text Input]]></title>
    <link href="http://fancypixel.github.io/blog/2015/06/11/ios9-notifications-and-text-input/"/>
    <updated>2015-06-11T11:03:06+02:00</updated>
    <id>http://fancypixel.github.io/blog/2015/06/11/ios9-notifications-and-text-input</id>
    <content type="html"><![CDATA[<p>When iOS8 opened the API to have actionable notifications many of us were disappointed that the text input action used in Messages wasn&rsquo;t available. It turns out that with iOS9 this API is now public, although as I&rsquo;m writing this the documentation doesn&rsquo;t mention it. After some digging in the UIKit changelog I was able to build a sample making use of this new behavior.<br/>
Like with iOS8 the NDA is more relaxed this year, but it still forbids showing screenshots. In any case, you&rsquo;ll find the full sample <a href="https://github.com/FancyPixel/text-notification-sample">on GitHub</a>.<br/>
Let&rsquo;s take a step by step look at what changed.</p>

<!-- More -->


<h1>Requesting the permission</h1>

<p>First of all we need to ask the permission to the user before we can start sending notifications. We start off by building a new <code>UIMutableUserNotificationAction</code>, that alongside the main properties of the notification will also specify the desired behavior:</p>

<pre><code class="swift">let textAction = UIMutableUserNotificationAction()
textAction.identifier = "TEXT_ACTION"
textAction.title = "Reply"
textAction.activationMode = .Background
textAction.authenticationRequired = false
textAction.destructive = false
textAction.behavior = .TextInput
</code></pre>

<p>The <code>behavior</code> property is a new addition of iOS9 and holds the <code>UIUserNotificationActionBehavior</code> enum:</p>

<pre><code class="swift">enum UIUserNotificationActionBehavior : UInt {
  case Default // the default action behavior
  case TextInput // system provided action behavior, allows text input from the user
}
</code></pre>

<p>With that out of the way the rest of the configuration didn&rsquo;t change much from iOS8:</p>

<pre><code class="swift">let category = UIMutableUserNotificationCategory()
category.identifier = "CATEGORY_ID"
category.setActions([textAction], forContext: .Default)
category.setActions([textAction], forContext: .Minimal)

let categories = NSSet(object: category) as! Set&lt;UIUserNotificationCategory&gt;
let settings = UIUserNotificationSettings(forTypes: [.Alert, .Badge, .Sound], categories: categories)
UIApplication.sharedApplication().registerUserNotificationSettings(settings)
</code></pre>

<p>One minor difference here is due to the new Swift 2 syntax, instead of:</p>

<pre><code class="swift">UIUserNotificationType.Alert | UIUserNotificationType.Sound | UIUserNotificationType.Badge
</code></pre>

<p>we need to use the much nicer</p>

<pre><code class="swift">[.Alert, .Sound, .Badge]
</code></pre>

<p>That&rsquo;s it, once the user grants the permission we can schedule a new local notification to test this out:</p>

<pre><code class="swift">static func scheduleNotification() {
    let now: NSDateComponents = NSCalendar.currentCalendar().components([.Hour, .Minute], fromDate: NSDate())

    let cal = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)!
    let date = cal.dateBySettingHour(now.hour, minute: now.minute + 1, second: 0, ofDate: NSDate(), options: NSCalendarOptions())
    let reminder = UILocalNotification()
    reminder.fireDate = date
    reminder.alertBody = "You can now reply with text"
    reminder.alertAction = "Cool"
    reminder.soundName = "sound.aif"
    reminder.category = "CATEGORY_ID"

    UIApplication.sharedApplication().scheduleLocalNotification(reminder)

    print("Firing at \(now.hour):\(now.minute+1)")
}
</code></pre>

<h1>Receiving the response</h1>

<p>Once the user activates the action and writes the reply our <code>AppDelegate</code> is called, receiving a new delegate message introduced in iOS9:</p>

<pre><code class="swift">func application(application: UIApplication, handleActionWithIdentifier identifier: String?, forLocalNotification notification: UILocalNotification, withResponseInfo responseInfo: [NSObject : AnyObject], completionHandler: () -&gt; Void) {
</code></pre>

<p>The text is stored in the <code>responseInfo</code> under the <code>UIUserNotificationActionResponseTypedTextKey</code> key:</p>

<pre><code class="swift">let reply = responseInfo[UIUserNotificationActionResponseTypedTextKey]
</code></pre>

<p>And that&rsquo;s it. A welcome addition to the API, let&rsquo;s hope that all the major messaging apps will adopt it soon.<br/>
You can find the full sample <a href="https://github.com/FancyPixel/text-notification-sample">here</a>. Once you run the app and schedule the notification, hop back to the home screen and you&rsquo;ll be able to reply with some text, that will be displayed in the app&rsquo;s view controller.</p>

<p>Until next time.<br/>
Andrea - <a href="https://twitter.com/theandreamazz">@theandreamazz</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APIs with Rails:<br/>render :json => the_simple_way]]></title>
    <link href="http://fancypixel.github.io/blog/2015/06/01/apis-with-rails-render-json-the-simple-way/"/>
    <updated>2015-06-01T14:50:41+02:00</updated>
    <id>http://fancypixel.github.io/blog/2015/06/01/apis-with-rails-render-json-the-simple-way</id>
    <content type="html"><![CDATA[<p>Lately my work at <a href="http://fancypixel.it">Fancy Pixel</a> has focused on the backend of a product we&rsquo;re about to launch and for which we decided to build a JSON API-only server. These APIs can be consumed from third party clients/services but are also used by our frontend. In this short report I&rsquo;d like to share with you the simple solution that we&rsquo;re using for the JSON generation and that in my humble opinion can be a quick and easy alternative to most commonly used systems like <a href="https://github.com/rails/jbuilder">Jbuilder</a> or <a href="https://github.com/rails-api/active_model_serializers">ActiveModel::Serializers</a>.</p>

<!-- More -->


<p>Rails, one of my favourite work buddies that I happened to use several times on projects that included the development of APIs. Due to personal curiosity, during the years I had the opportunity to try several solutions for JSON generation and I have to say that sometimes I found some difficulties with certain tecnologies: great for the majority of their functionalities sometimes they may force you to take weird paths to achieve the desired result. To be honest, the main reason for this continuative experimentation is probably the constant search for the top balance between comfort/ease of use/development-speed and performances and after all this test and try I arrived to the current solution, that probably is not something new, but that in my opinion can give somebody an alternative idea combining together great flexibility and bare metal performances.</p>

<h2>To cut a long story short&hellip;</h2>

<p>I don&rsquo;t want to dwell with epic tales or &ldquo;disquisitions about the gender of the Angels&rdquo; so I built a trivial <a href="https://github.com/FancyPixel/serializers_demo">demo app</a> that you can find on our GitHub account, to show you what I&rsquo;m talking about.</p>

<p>Let&rsquo;s rapidly setup our application:</p>

<pre><code class="bash">git clone "https://github.com/FancyPixel/serializers_demo"
cd serializers_demo
bundle
rake db:create &amp;&amp; rake db:migrate &amp;&amp; rake db:seed
</code></pre>

<p>For the purposes of this article I decided to use <a href="https://github.com/rails-api/rails-api">rails-api</a> (if you don&rsquo;t already know it I reccomend you to give it a try) instead of standard Rails, for the simple fact that this is what we&rsquo;re using right now in the project I mentioned at the beginning of this post. Obviously the same concepts apply identically to <em>vanilla</em> Rails.
Let&rsquo;s open together the code and take a rapid look at it: as you can see these few lines of source do nothing but respond to three routes and if you take a look at <code>config/routes.rb</code> you&rsquo;ll find something like:</p>

<pre><code class="ruby"># config/routes.rb

Rails.application.routes.draw do
  namespace :v1, defaults: { format: :json } do
    get :jbuilder, to: 'comparison#jbuilder'
    get :ams, to: 'comparison#ams'
    get :simple, to: 'comparison#simple'
  end
end 
</code></pre>

<p>As you can see I&rsquo;ve set <code>json</code> as the default format and I defined a namespace in such a way to replicate a typical process of APIs versioning.
Let&rsquo;s jump to the only existing controller (<code>comparison_controller</code>) where we find the implementation of the actions called from the routes. Each of these actions does exactly the same: load a bunch of records from the DB and render it as JSON, but each one does the rendering in its own way i.e. using respectively jbuilder, ActiveModel::Serializers and &ldquo;my solution&rdquo; that I&rsquo;m going to call &ldquo;simple&rdquo;&hellip;  what a fancy name uh?</p>

<p>We&rsquo;re not going to focus on the first two systems, because chances are that you master those tecnologies better than me already and, also, there is nothing out of standard in my implementations, but instead we&rsquo;re jumping feet together to the <code>simple</code> action. Like the competitors, it does nothing more than render some JSON, but this time the <code>serialize_awesome_stuffs</code> helper method is called. This method is defined in the <code>V1::SimpleAwesomeStuffSerializer</code> module that is included by the controller. You can find the module under <code>app/serializers/v1</code> and if you&rsquo;re going to open the file you&rsquo;ll notice that it&rsquo;s just a plain Ruby module defining methods.</p>

<pre><code class="ruby"># app/serializers/v1/simple_awesome_stuff_serializer.rb

module V1
  module SimpleAwesomeStuffSerializer

    def serialize_awesome_stuff(awesome_stuff = @awesome_stuff)
      {
          name: awesome_stuff.name,
          some_attribute: awesome_stuff.some_attribute,
          a_counter: awesome_stuff.a_counter
      }
    end

    def serialize_awesome_stuffs(awesome_stuffs = @awesome_stuffs)
      {
          awesome_stuffs: awesome_stuffs.map do |awesome|
            serialize_awesome_stuff awesome
          end
      }
    end
  end
end
</code></pre>

<p>Both the methods do nothing more that returning an Hash defining key-values couples that we&rsquo;re willing to return as JSON. In particular <code>serialize_awesome_stuffs</code> creates an <code>Array</code> of <code>Hash</code> and internally, just for DRYing things up a bit, calls <code>serialize_awesome_stuff</code> (singular). Maybe the overall naming is not the best in the world, uh? Bonus point: defining the method&rsquo;s parameter <code>awesome_stuffs = @awesome_stuffs</code> allows us to make our code lighter and more readable, because if we remained adherent to conventional variable naming, probably our controller is defining something like <code>@awesome_stuff</code> (and as a matter of fact, we did) that is directly visible and usable by our module. If we&rsquo;re going to have a bout of creativity and want to use our personal variables names, we won&rsquo;t have any sort of problem.</p>

<p>Take this piece of code as example:</p>

<pre><code class="ruby"># some_controller.rb

def some_action
  @my_personal_awesome_stuffs = AwesomeStuff.all
  render json: serialize_awesome_stuffs @my_personal_awesome_stuffs
end
</code></pre>

<p>and everything will work as expected.</p>

<h2>Step-by-step: let&rsquo;s complicate things a bit</h2>

<p>Let&rsquo;s raise a bit the complexity of our example, adding a <code>User</code> model and defining a one-to-many relationship with our <code>AwesomeStuff</code>:</p>

<pre><code class="bash">rails g model user name:string
</code></pre>

<p>add the <code>User</code> reference in <code>AwesomeStuff</code>:</p>

<pre><code class="bash">rails g migration add_user_reference_to_awesome_stuff user:references
</code></pre>

<p>and migrate everything:</p>

<pre><code class="bash">rake db:migrate
</code></pre>

<p>Define now the relationships between models:</p>

<pre><code class="ruby"># app/models/awesome_stuff.rb
class AwesomeStuff &lt; ActiveRecord::Base
  belongs_to :user
end

# app/models/user.rb
class User &lt; ActiveRecord::Base
  has_many :awesome_stuffs
end
</code></pre>

<p>launch the Rails console with <code>rails c</code> and insert some test data into the DB:</p>

<pre><code class="ruby"># Add five users
users = []
5.times {|n| users &lt;&lt; User.create(name: "user_#{n}") }

# Randomly associate our awesome records™ to users
AwesomeStuff.all.each { |aww| aww.update user: users.sample }

# A rapid test confirms that...
User.first.awesome_stuffs

=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;AwesomeStuff id: ... ... &gt;]&gt;
</code></pre>

<p>Now that everything is prepared, let&rsquo;s follow some of the steps we&rsquo;d usually do during an API creation. Let&rsquo;s create a <code>UserController</code> through which return to the client also user&rsquo;s associated awesome records™.
Create <code>users_controller.rb` under</code>app/controllers/v1/<code>and add</code>index&#8220;` action:</p>

<pre><code class="ruby"># app/controllers/v1/users_controller.rb

module V1
  class UsersController &lt; ApplicationController
    include V1::UsersSerializer

    def index
      @users = User.all.includes(:awesome_stuffs)
      render json: serialize_users
    end
  end
end
</code></pre>

<p>As you can see I already added some stuff that we&rsquo;ll need in short, that is the <code>V1::UsersSerializer</code> module. If you haven&rsquo;t already, notice the scoping (V1) of our serializers: in doing so we can follow the evolution of our API&rsquo;s versions with no hassles, possibly going to redefine the behavior of only serializers that may change.
Do not forget to add new routes:</p>

<pre><code class="ruby"># config/routes.rb

Rails.application.routes.draw do
  namespace :v1, defaults: { format: :json } do
    get :jbuilder, to: 'comparison#jbuilder'
    get :ams, to: 'comparison#ams'
    get :simple, to: 'comparison#simple'

    # Let's add the 'index' only
    resources :users, only: :index
  end
end
</code></pre>

<p>What are we going to add to our <code>UsersSerializer</code>? A first idea should be something like:</p>

<pre><code class="ruby"># app/serializers/v1/users_serializer.rb

module V1
  module UsersSerializer

    def serialize_users(users = @users)
      {
        users: users.map do |user|
          {
              id: user.id,
              name: user.name,
              awesome_stuffs: user.awesome_stuffs.map do |aww|
                {
                    name: aww.name,
                    some_attribute: aww.some_attribute,
                    a_counter: aww.a_counter
                }
              end
          }
        end
      }
    end
  end
end
</code></pre>

<p>Ok, but there&rsquo;s a lot of code smell here right? We already saw some of this stuff, let&rsquo;s try to reuse it:</p>

<pre><code class="ruby"># app/serializers/v1/users_serializer.rb

module V1
  module UsersSerializer
    include V1::SimpleAwesomeStuffSerializer

    def serialize_users(users = @users)
      {
        users: users.map do |user|
          {
              id: user.id,
              name: user.name,
              awesome_stuffs: user.awesome_stuffs.map do |aww|
                serialize_awesome_stuff aww
              end
          }
        end
      }
    end
  end
end
</code></pre>

<p>Very well, but we can do better. Our API will probably have a route for a user&rsquo;s data i.e. something like <code>/v1/users/1</code> so we can move in advance and simultaneously dry up our current code:</p>

<pre><code class="ruby"># app/serializers/v1/users_serializer.rb

module V1
  module UsersSerializer
    include V1::SimpleAwesomeStuffSerializer

    def serialize_user(user = @user)
      {
          id: user.id,
          name: user.name,
      }
    end

    def serialize_users(users = @users)
      {
        users: users.map do |user|
          serialize_user(user).merge(
            {
                awesome_stuffs: user.awesome_stuffs.map do |aww|
                  serialize_awesome_stuff aww
                end
            }
          )
        end
      }
    end
  end
end
</code></pre>

<p>Ok, we&rsquo;ve just &ldquo;killed two birds with one stone&rdquo;. (the birds are doing well, don&rsquo;t worry)
As you&rsquo;ll have noticed it&rsquo;s possible to obtain a further improvement:</p>

<pre><code class="ruby"># app/serializers/v1/users_serializer.rb

module V1
  module UsersSerializer
    include V1::SimpleAwesomeStuffSerializer

    def serialize_user(user = @user)
      {
          id: user.id,
          name: user.name
      }
    end

    def serialize_users(users = @users)
      {
        users: users.map do |user|
          serialize_user(user).merge(serialize_awesome_stuffs(user.awesome_stuffs))
        end
      }
    end
  end
end
</code></pre>

<p>What you&rsquo;ve seen so far is a simple example of what it&rsquo;s possibile to do with the tools we already have at hand and mainly wants to be an idea for those wo are constantly looking for the best performances and simplicity.</p>

<p>We reached the end and I hope I have not bored you too much, but if you got to this point, I probably didn&rsquo;t :)
What you have seen today may or may not be liked, but I personally find it a surely performant system that offers pure modularity, extensibility and code reuse.</p>

<p>Feel free to leave a comment, we’d really love to hear your feedback.</p>

<p>See ya soon!</p>

<p>Alessandro - <a href="https://twitter.com/Aleverla">@Aleverla</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulps: new open source WatchKit app]]></title>
    <link href="http://fancypixel.github.io/blog/2015/04/13/gulps-new-open-source-watchkit-app/"/>
    <updated>2015-04-13T21:26:20+02:00</updated>
    <id>http://fancypixel.github.io/blog/2015/04/13/gulps-new-open-source-watchkit-app</id>
    <content type="html"><![CDATA[<p>We released a new app on the <a href="https://itunes.apple.com/us/app/gulps/id979057304?ls=1&amp;mt=8">AppStore</a> and decided to open source it. The app is called Gulps, a simple tracker of your daily water consumption. Gulps was a fun little side project built to learn a bit more about WatchKit and to strengthen my Swift-fu.<br/>
If you read our latest post on <a href="http://fancypixel.github.io/blog/2015/03/29/share-data-between-watchkit-and-your-app-with-realm/">how to share data with Realm</a>, you&rsquo;ll find a lot of code in common in this app, but there&rsquo;s also quite a bit of new stuff that&rsquo;s worth checking out. For starters I personally really like the water meter that follows your device movement, made possible by the amazing <a href="https://github.com/dulaccc/DPMeterView">DPMeterView</a>. You might also like the Facebook Paper-like wavy effect in the onboarding, provided by one of my pride and joys, <a href="https://github.com/andreamazz/AMWaveTransition">AMWaveTransition</a>.<br/>
You&rsquo;ll find the source <a href="https://github.com/FancyPixel/gulps">here</a>.</p>

<p>Let us know what you think.<br/>
Until next time.</p>

<p>Andrea - <a href="https://twitter.com/theandreamazz">@theandreamazz</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Share data between WatchKit and your app with Realm]]></title>
    <link href="http://fancypixel.github.io/blog/2015/03/29/share-data-between-watchkit-and-your-app-with-realm/"/>
    <updated>2015-03-29T15:00:32+02:00</updated>
    <id>http://fancypixel.github.io/blog/2015/03/29/share-data-between-watchkit-and-your-app-with-realm</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a busy year for iOS developers. We got a slew of new toys to play with: a new version of iOS, new frameworks, a new language, new screen sizes and some new hardware to put on our wrists, just as soon as we thought that watches were anachronistic.<br/>
New technology is always exciting, but keeping up to date can be a daunting task when deadlines keep getting closer. Lately I&rsquo;ve been taking some time off to delve deeper in these new topics and build a simple app out of it (that we are planning to open source). At the time of this writeup the app is still waiting to be reviewed, so we&rsquo;re going to just focus on something that I learned in the process and that can be useful to a lot of other iOS devs: sharing data between your app and its WatchKit extension, using <a href="http://realm.io/">Realm</a>.</p>

<!-- More -->


<h1>Why Realm</h1>

<p>Realm is a great replacement for both SQLite and Core Data, it offers a quick and painless way to persist data in your iOS (and Android) app. The thing that makes it so great is the ease of use, it reduces your boilerplate code to next to nothing (I&rsquo;m watching you, Core Data), keeping things at a high level of abstraction (I&rsquo;m watching you SQLite) and&hellip; it&rsquo;s fast. It really is a brilliant piece of software, and I urge you to checkout the <a href="http://realm.io/docs/cocoa/0.91.1/">official documentation</a> if you&rsquo;re in need of a persistence framework for your app.</p>

<h1>The sample app</h1>

<p>We&rsquo;re going to learn how to share data between an app and its WatchKit extension, and what better way to use a sample app as reference?.
I&rsquo;m not a fan of TODO app demos, they always feel&hellip; unimaginative&hellip; but I have to admit that they are the perfect sample for a task like this. So, bear with me, let me introduce to you another TODO sample app: <em>Done!</em>, a simple TODO list where we can add items and mark them as done from our Apple Watch.</p>

<h1>Setting up Realm</h1>

<p>WatchKit extensions are just another target inside your app, just like Today extensions, so they are packed alongside your app, but they have their own life, and most importantly, their own bundle identifier. This means that data stored within an app is not visible to the extension and vice versa. Apple offers a way to solve the issue through app groups.<br/>
App groups, like bundle identifiers, are defined by a reverse URI and they are prefixed with <code>group.</code>. They let you share data between your apps and are tightly bound to your provisioning profile (luckily Xcode handles their creation in your developer portal with ease).<br/>
We can take advantage of that to create our Realm database in a shared space that will be visible (and writeable) by both our app and the app&rsquo;s WatchKit extension. Let&rsquo;s start by creating the group in our project&rsquo;s capabilities section:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-03-29/appgroup.png" width="640" height="150" title="'App groups'" ></p>

<p>Once this is out of the way we can tell Realm to store the database inside the group.
We&rsquo;ll do so in our AppDelegate&rsquo;s <code>application(application: didFinishLaunchingWithOptions launchOptions:)</code> function:</p>

<pre><code>let directory: NSURL = NSFileManager.defaultManager().containerURLForSecurityApplicationGroupIdentifier("group.it.fancypixel.Done")!
let realmPath = directory.path!.stringByAppendingPathComponent("db.realm")
RLMRealm.setDefaultRealmPath(realmPath)
</code></pre>

<p>That&rsquo;s it, Realm is ready to go, we just need to define a model to persist. Let&rsquo;s do it:</p>

<pre><code>// Entry.swift
import Realm

class Entry: RLMObject {
  dynamic var title = ""
  dynamic var completed = false
}
</code></pre>

<h1>ViewController</h1>

<p>The ViewController handling the TODO list will be rather simple, it&rsquo;ll hold a plain <code>UITableView</code> with a custom header presenting the <code>UITextField</code> for the user&rsquo;s input, nothing fancy:</p>

<pre><code>// ViewController.swift
import Realm
import UIKit

class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource, UITextFieldDelegate {

    @IBOutlet var tableView: UITableView!
    var dataSource: RLMResults!

    override func viewDidLoad() {
        super.viewDidLoad()
        reloadEntries()
    }

    func tableView(tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {
        let container = UIView(frame: CGRectMake(0, 0, self.view.frame.size.width, 60))
        let textField = UITextField(frame: CGRectMake(10, 10, self.view.frame.size.width - 20, 40))
        textField.delegate = self
        textField.textColor = UIColor.whiteColor()
        let placeholer = NSAttributedString(string: "Add an item", attributes: [NSForegroundColorAttributeName: UIColor.lightGrayColor()])
        textField.attributedPlaceholder = placeholer
        container.addSubview(textField)
        return container
    }

    func reloadEntries() {
        dataSource = Entry.allObjects()
        self.tableView.reloadData()
    }

    func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
        textField.resignFirstResponder()

        let realm = RLMRealm.defaultRealm()
        realm.beginWriteTransaction()
        let entry = Entry()
        entry.title = textField.text
        entry.completed = false
        realm.addObject(entry)
        realm.commitWriteTransaction()
        reloadEntries()
        return true
    }

    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return Int(dataSource.count)
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
        var cell = tableView.dequeueReusableCellWithIdentifier("Cell") as UITableViewCell
        let entry = dataSource[UInt(indexPath.row)] as Entry
        cell.textLabel!.text = entry.title
        cell.accessoryType = entry.completed ? .Checkmark : .None
        return cell
    }

    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        let entry = dataSource[UInt(indexPath.row)] as Entry
        let realm = RLMRealm.defaultRealm()
        realm.beginWriteTransaction()
        entry.completed = !entry.completed
        realm.commitWriteTransaction()
        reloadEntries()
    }
}
</code></pre>

<p>As you can see we are retrieving the table view&rsquo;s items from Realm with a simple call:</p>

<pre><code>Entry.allObjects()
</code></pre>

<p>and storing the changes with a couple of lines:</p>

<pre><code>realm.beginWriteTransaction()
let entry = Entry
entry.title = textField.text
entry.completed = false
realm.addObject(entry)
realm.commitWriteTransaction()
</code></pre>

<p>If you worked with Core Data in the past you should have a better understanding of my claim <em>&ldquo;less boilerplate code&rdquo;</em>.</p>

<h1>WatchKit</h1>

<p>Ok, new technology, new framework, so much to learn, right?<br/>
Well, it turns out that Apple did some thinking on this, and for what I witnessed, developing a Watch app is going to feel familiar for a lot of Cocoa and Cocoa Touch developers, albeit with some significant philosophical changes. First things first, let&rsquo;s create a new target holding the Watch app:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-03-29/newtarget.png" width="640" height="340" title="'WatchKit target'" ></p>

<p>Then, the layout. We won&rsquo;t be using Autolayout, but something reminiscing a simplified version of Android&rsquo;s linear and relative layouts (no need to touch beefy XML files though, storyboards are still there for us). The layout for this will be a <code>WKInterfaceTable</code> with a custom <code>TableRowController</code>, holding a <code>WKInterfaceImage</code> and a <code>WKInterfaceLabel</code>:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-03-29/storyboard.png" width="600" height="260" title="'WatchKit storyboard'" ></p>

<p>The custom <code>TableRowController</code> is a plain class with a couple of properties, so let&rsquo;s take a look at this first:</p>

<pre><code>class EntryTableRowController: NSObject {
    @IBOutlet var imageCheck: WKInterfaceImage!
    @IBOutlet var textLabel: WKInterfaceLabel!
}
</code></pre>

<p>Pretty straightforward, think of it as the equivalent of a custom <code>UITableViewCell</code>.<br/>
Let&rsquo;s take a look on how to populate the table:</p>

<pre><code>override func awakeWithContext(context: AnyObject?) {
    super.awakeWithContext(context)

    let directory: NSURL = NSFileManager.defaultManager().containerURLForSecurityApplicationGroupIdentifier("group.it.fancypixel.Done")!
    let realmPath = directory.path!.stringByAppendingPathComponent("db.realm")
    RLMRealm.setDefaultRealmPath(realmPath)
    reloadTableData()
}

func reloadTableData() {
    let realm = RLMRealm.defaultRealm()
    let dataSource = Entry.allObjects()

    watchTable.setNumberOfRows(Int(dataSource.count), withRowType: "EntryRow")

    for index in 0..&lt;Int(dataSource.count) {
        let entry = dataSource[UInt(index)] as Entry
        if let row = watchTable.rowControllerAtIndex(index) as? EntryTableRowController {
            row.textLabel.setText(entry.title)
            let imageName = entry.completed ? "check-completed" : "check-empty"
            row.imageCheck.setImageNamed(imageName)
        }
    }
}
</code></pre>

<p>That&rsquo;s a little different from what we&rsquo;re used in UIKit. No <code>delegate</code> nor <code>dataSource</code>, in WatchKit we explicitly define every row before showing the table.<br/>
Also, as you can see in the <code>awakeWithContext</code> function, we are setting up Realm as we did in the main app. As a side note, the pieces of code that are shared between the two targets (in our case, everything concerning the model) should be moved in a custom framework to avoid code duplication. For the purpose of this sample I opted to duplicate the Realm initialization and shared the model between the two targets, but in a more structured app I would definitely take the framework route.
If we build and run we can add an item on the phone, and once we reload the app we&rsquo;ll see the same item in the watch extension too.<br/>
That doesn&rsquo;t feel very responsive though, right? We&rsquo;ll fix that in a bit, but first let&rsquo;s add the ability to mark an item as <em>done</em> from the watch:</p>

<pre><code class="">override func table(table: WKInterfaceTable, didSelectRowAtIndex rowIndex: Int) {
    let dataSource = Entry.allObjects()
    let entry = dataSource[UInt(rowIndex)] as Entry
    let realm = RLMRealm.defaultRealm()
    realm.beginWriteTransaction()
    entry.completed = !entry.completed
    realm.commitWriteTransaction()
    reloadTableData()
}
</code></pre>

<p>That pretty much covers it. Right now it&rsquo;s even more apparent that even if the two apps are communicating, there&rsquo;s no real sense of interaction, since we need to reload the app to see the changes.</p>

<h1>Syncing data</h1>

<p>We need to somehow advertise that our watch app or our main app performed something meaningful. There are <em>official</em> ways to do that, and you can read more about them on <a href="http://natashatherobot.com/watchkit-open-ios-app-from-watch/">this blog post from Natasha The Robot</a>, but in this case I want to show you how a brilliant library called <a href="https://github.com/mutualmobile/MMWormhole">MMWormHole</a> can abstract this task for us.</p>

<h2>MMWormHole</h2>

<p>MMWormhole creates a bridge between an app and its extensions. The API is clear and concise and it has a delightfully geeky name. It works like a pub/sub system, one end registers its interest for a kind of message (defined by a string identifier), and the other end can broadcast a new event. When the event is raised the subscriber&rsquo;s handler is fired. Sounds like something we can leverage from our app. Let&rsquo;s start by registering interest in <code>watch</code> updates on our main app:</p>

<pre><code>self.wormhole.listenForMessageWithIdentifier("watchUpdate", listener: { (_) -&gt; Void in
    self.reloadEntries()
})
</code></pre>

<p>and on our watch app we&rsquo;ll listen for <code>main</code> updates:</p>

<pre><code>self.wormhole.listenForMessageWithIdentifier("mainUpdate", listener: { (_) -&gt; Void in
    self.reloadTableData()
})
</code></pre>

<p>And that&rsquo;s it. When something changes in our model we just need to call these function:</p>

<pre><code>// From the watch
self.wormhole.passMessageObject("update", identifier: "watchUpdate")

// From the main app
self.wormhole.passMessageObject(someObject, identifier: "mainUpdate")
</code></pre>

<h1>Realm notifications</h1>

<p><em>Update</em></p>

<p>Once this post was live, Tim Anglade from Realm reached out to me and was kind enough to point out that there&rsquo;s a built-in notification system in Realm, so MMWormHole in this case isn&rsquo;t really needed. The API is really easy to use and requires no configuration, here&rsquo;s how it works:</p>

<pre><code>realmToken = RLMRealm.defaultRealm().addNotificationBlock { note, realm in
    self.reloadEntries()
}
</code></pre>

<p>As long as we keep a strong pointer to the token, the system fires the notification block as soon as a write transaction is committed. You can find the updated code in the sample app.</p>

<h2>Demo</h2>

<p>Here&rsquo;s the demo app in all of its glory:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-03-29/screenshot.gif" width="600" title="'Done'" ></p>

<p>As you can see it&rsquo;s really easy to bootstrap a simple app for WatchKit, and thanks to a couple of great open source libraries adding persistence and interactivity is a painless effort. A big <em>thank you</em> to both the Realm team and Mutual Mobile for the amazing work on MMWormHole.</p>

<p>As usual, you&rsquo;ll find the source code of the demo app on our <a href="https://github.com/FancyPixel/done-swift">GitHub page</a>. Feel free to leave a comment, we&rsquo;d love to hear your feedback.</p>

<p>Until next time,</p>

<p>Andrea - <em><a href="https://twitter.com/theandreamazz">@theandreamazz</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React + Flux backed by Rails API - Part 3]]></title>
    <link href="http://fancypixel.github.io/blog/2015/01/30/react-plus-flux-backed-by-rails-api-part-3/"/>
    <updated>2015-01-30T15:40:43+01:00</updated>
    <id>http://fancypixel.github.io/blog/2015/01/30/react-plus-flux-backed-by-rails-api-part-3</id>
    <content type="html"><![CDATA[<p>This is the last part of &ldquo;<em>React + Flux backed by Rails API</em>&rdquo;, make sure to check out <a href="http://fancypixel.github.io/blog/2015/01/28/react-plus-flux-backed-by-rails-api/">Part 1</a> and <a href="http://fancypixel.github.io/blog/2015/01/29/react-plus-flux-backed-by-rails-api-part-2/">Part 2</a> if you have missed them.</p>

<p>In part 1 we built a Rails API for a tiny clone of Medium, called appropriately <em>Small</em>. In part 2 we went through the setup of a React app with a Flux architecture, and built our authentication workflow. We close this series by providing the list of the stories and a creation page, protected by authentication. A note of warning: this is a quick and sometimes naive implementation, its main purpose is to show you how to get started with React and Flux, that&rsquo;s why we didn&rsquo;t put too much effort in handling possible errors or, for that matter, even showing progress indicators.</p>

<!-- More -->


<h1>Listing stories</h1>

<p>Looking back at our routes, I defined a default route, mounted under <code>/stories</code>, handled by a component called <code>StoriesPage</code>. This component will abide the flux architecture, therefore its only goal in life will be displaying data fetched by a store, and re-render when something has changed. Before diving in this component, let&rsquo;s create a store then:</p>

<pre><code class="js">// ./scripts/stores/StoryStore.rect.jsx
var SmallAppDispatcher = require('../dispatcher/SmallAppDispatcher.js');
var SmallConstants = require('../constants/SmallConstants.js');
var EventEmitter = require('events').EventEmitter;
var assign = require('object-assign');
var WebAPIUtils = require('../utils/WebAPIUtils.js');

var ActionTypes = SmallConstants.ActionTypes;
var CHANGE_EVENT = 'change';

var _stories = [];
var _errors = [];
var _story = { title: "", body: "", user: { username: "" } };

var StoryStore = assign({}, EventEmitter.prototype, {

  emitChange: function() {
    this.emit(CHANGE_EVENT);
  },

  addChangeListener: function(callback) {
    this.on(CHANGE_EVENT, callback);
  },

  removeChangeListener: function(callback) {
    this.removeListener(CHANGE_EVENT, callback);
  },

  getAllStories: function() {
    return _stories;
  },

  getStory: function() {
    return _story;
  },

  getErrors: function() {
    return _errors;
  }

});

StoryStore.dispatchToken = SmallAppDispatcher.register(function(payload) {
  var action = payload.action;

  switch(action.type) {

    case ActionTypes.RECEIVE_STORIES:
      _stories = action.json.stories;
      StoryStore.emitChange();
      break;

    case ActionTypes.RECEIVE_CREATED_STORY:
      if (action.json) {
        _stories.unshift(action.json.story);
        _errors = [];
      }
      if (action.errors) {
        _errors = action.errors;
      }
      StoryStore.emitChange();
      break;

    case ActionTypes.RECEIVE_STORY:
      if (action.json) {
        _story = action.json.story;
        _errors = [];
      }
      if (action.errors) {
        _errors = action.errors;
      }
      StoryStore.emitChange();
      break;
  }

  return true;
});

module.exports = StoryStore;
</code></pre>

<p>At this point this should look familiar, we define our private state, the properties to access it from outside, and we register our callbacks. Once a new action tagged <code>RECEIVE_STORIES</code> is dispatched, we take the content of the payload, store it in the store&rsquo;s state and emit a change. The <code>RECEIVE_STORIES</code> is generated when <code>WebAPIUtils</code> receives the XHR response from the server, just as the login process. What component does fire this AJAX request though? That&rsquo;s a view action, initiated by the user when he requests the <code>/stories</code> route. Here&rsquo;s the component of this route handler:</p>

<pre><code class="js">// ./scripts/components/StoriesPage.react.jsx
var React = require('react');
var WebAPIUtils = require('../../utils/WebAPIUtils.js');
var StoryStore = require('../../stores/StoryStore.react.jsx');
var ErrorNotice = require('../../components/common/ErrorNotice.react.jsx');
var StoryActionCreators = require('../../actions/StoryActionCreators.react.jsx');
var Router = require('react-router');
var Link = Router.Link;
var timeago = require('timeago');

var StoriesPage = React.createClass({

  getInitialState: function() {
    return { 
      stories: StoryStore.getAllStories(), 
      errors: []
    };
  },

  componentDidMount: function() {
    StoryStore.addChangeListener(this._onChange);
    StoryActionCreators.loadStories();
  },

  componentWillUnmount: function() {
    StoryStore.removeChangeListener(this._onChange);
  },

  _onChange: function() {
    this.setState({ 
      stories: StoryStore.getAllStories(),
      errors: StoryStore.getErrors()
    }); 
  },

  render: function() {
    var errors = (this.state.errors.length &gt; 0) ? &lt;ErrorNotice errors={this.state.errors}/&gt; : &lt;div&gt;&lt;/div&gt;;
    return (
      &lt;div&gt;
        {errors}
        &lt;div className="row"&gt;
          &lt;StoriesList stories={this.state.stories} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

var StoryItem = React.createClass({
  render: function() {
    return (
      &lt;li className="story"&gt;
        &lt;div className="story__title"&gt;
          &lt;Link to="story" params={ {storyId: this.props.story.id} }&gt;
            {this.props.story.title}
          &lt;/Link&gt;
        &lt;/div&gt;
        &lt;div className="story__body"&gt;{this.props.story['abstract']}...&lt;/div&gt;
        &lt;span className="story__user"&gt;{this.props.story.user.username}&lt;/span&gt;
        &lt;span className="story__date"&gt; - {timeago(this.props.story.created_at)}&lt;/span&gt;
      &lt;/li&gt;
      );
  }
});

var StoriesList = React.createClass({
  render: function() {
    return (
      &lt;ul className="large-8 medium-10 small-12 small-centered columns"&gt;
        {this.props.stories.map(function(story, index){
          return &lt;StoryItem story={story} key={"story-" + index}/&gt;
        })}
      &lt;/ul&gt;
    );
  }
});

module.exports = StoriesPage;
</code></pre>

<p>In this component I took advantage of the <code>componentDidMount</code> function to start the asynchronous request to our API. The stories are then retrieved from the aforementioned StoryStore and held in the component&rsquo;s state. In the <code>render</code> function I took the chance to show you a more React-y way to write a view, with modular and reusable components. These component might also live in separate files (or even projects), but for readability I put them in the same file. As you can see the page renders just one component, <code>StoriesList</code>, passing the stories list as props. The <code>StoriesList</code> uses the <code>.map</code> function to render one <code>StoryItem</code> component for each item in the stories array. Note how I needed to specify a unique key for the item (you could use an index as I did or even the story&rsquo;s <code>id</code>), this helps React keeping track of what element changed.<br/>
The last element of the chain is the <code>StoryItem</code> component, that renders the props provided by its parents. You might notice the weird css class names, bear with me, I&rsquo;m trying to get accustomed with the <a href="https://bem.info/method/">BEM methodology</a>.</p>

<h1>Loading a story</h1>

<p>If everything has gone smoothly we should see a list of stories, something like this:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-01-30/list.png" width="648" height="703" title="'Stories list'" ></p>

<p>What happens when I click a story? Looking back at our StoriesPage we have this bit of code:</p>

<pre><code class="html">  &lt;div className="story__title"&gt;
    &lt;Link to="story" params={ {storyId: this.props.story.id} }&gt;
      {this.props.story.title}
    &lt;/Link&gt;
  &lt;/div&gt;
</code></pre>

<p>and in our router we configured the route like this:</p>

<pre><code class="js">  &lt;Route name="story" path="/stories/:storyId" handler={StoryPage} /&gt;
</code></pre>

<p>This means that once we select an item from the list, the router will switch the current component (or handler) with the <code>StoryPage</code> component, passing along a query parameter named <code>storyId</code>. Our <code>StoryPage</code> will then be able to get that id, and create a new action, requesting the download of the selected item. As usual the request will be handled by the WebAPIUtils, the response will be encapsulated in a new action, handled by the store, that emits the change, ending with our <code>StoryPage</code> refreshing its content. If you followed along you should have this pattern memorized by now. If so, you have the Flux architecture figured out.<br/>
Just for kicks, here&rsquo;s the StoryPage:</p>

<pre><code class="js">var React = require('react');
var WebAPIUtils = require('../../utils/WebAPIUtils.js');
var StoryStore = require('../../stores/StoryStore.react.jsx');
var StoryActionCreators = require('../../actions/StoryActionCreators.react.jsx');
var State = require('react-router').State;

var StoryPage = React.createClass({

  mixins: [ State ],

  getInitialState: function() {
    return { 
      story: StoryStore.getStory(), 
      errors: []
    };
  },

  componentDidMount: function() {
    StoryStore.addChangeListener(this._onChange);
    StoryActionCreators.loadStory(this.getParams().storyId);
  },

  componentWillUnmount: function() {
    StoryStore.removeChangeListener(this._onChange);
  },

  _onChange: function() {
    this.setState({ 
      story: StoryStore.getStory(),
      errors: StoryStore.getErrors()
    }); 
  },

  render: function() {
    return (
      &lt;div className="row"&gt;
        &lt;div className="story__title"&gt;{this.state.story.title}&lt;/div&gt;
        &lt;div className="story__body"&gt;{this.state.story.body}&lt;/div&gt;
        &lt;div className="story__user"&gt;{this.state.story.user.username}&lt;/div&gt;
      &lt;/div&gt;
     );
  }

});

module.exports = StoryPage;
</code></pre>

<h1>Creating a new story</h1>

<p>We have one last thing to cover, and that&rsquo;s user input. We already did that in the authentication process, but without going into detail. Let&rsquo;s take a look at the <code>StoryNew</code> component:</p>

<pre><code class="js">// ./scripts/components/stories/StoryNew.react.jsx
var React = require('react');
var SmallAppDispatcher = require('../../dispatcher/SmallAppDispatcher.js');
var SmallConstants = require('../../constants/SmallConstants.js');
var WebAPIUtils = require('../../utils/WebAPIUtils.js');
var SessionStore = require('../../stores/SessionStore.react.jsx');
var StoryActionCreators = require('../../actions/StoryActionCreators.react.jsx');
var RouteActionCreators = require('../../actions/RouteActionCreators.react.jsx');

var StoryNew = React.createClass({

  componentDidMount: function() {
    if (!SessionStore.isLoggedIn()) { 
      RouteActionCreators.redirect('app');
    }
  },

  _onSubmit: function(e) {
    e.preventDefault();
    var title = this.refs.title.getDOMNode().value;
    var body = this.refs.body.getDOMNode().value;
    StoryActionCreators.createStory(title, body);
  },

  render: function() {
    return (
      &lt;div className="row"&gt;
        &lt;form onSubmit={this._onSubmit} className="new-story"&gt;
          &lt;div className="new-story__title"&gt;
            &lt;input type="text" placeholder="Title" name="title" ref="title" /&gt; 
          &lt;/div&gt;
          &lt;div className="new-story__body"&gt;
            &lt;textarea rows="10" placeholder="Your story..." name="body" ref="body" /&gt; 
          &lt;/div&gt;
          &lt;div className="new-story__submit"&gt;
            &lt;button type="submit"&gt;Create&lt;/button&gt;
          &lt;/div&gt;
         &lt;/form&gt;
       &lt;/div&gt;
     );
  }

});

module.exports = StoryNew;
</code></pre>

<p>In the <code>render</code> function we defined an html form with a text input and a textarea. Notice the <code>ref</code> property of those tags, its value is the binding we&rsquo;ll use to retrieve their content when the users submits the form, using the <code>getDOMNode()</code> function. The submit once again kickstarts the Flux chain, by creating a view action. There&rsquo;s one thing to note here: posting a new story is an action performed by an authenticated user, so our WebAPIUtils method will look like this:</p>

<pre><code class="js">  createStory: function(title, body) {
    request.post('http://localhost:3002/v1/stories')
      .set('Accept', 'application/json')
      .set('Authorization', sessionStorage.getItem('accessToken'))
      .send({ story: { title: title, body: body } })
      .end(function(error, res){
        if (res) {
          if (res.error) {
            var errorMsgs = _getErrors(res);
            ServerActionCreators.receiveCreatedStory(null, errorMsgs);
          } else {
            json = JSON.parse(res.text);
            ServerActionCreators.receiveCreatedStory(json, null);
          }
        }
      });
  }
</code></pre>

<p>Notice how we are passing the user&rsquo;s access token in the request header. That&rsquo;s it, our Rails API will authenticate the user thanks to that header, and the action will be performed.</p>

<h1>Wrap up</h1>

<p>This concludes this tiny application. As stated above, this is a naive implementation, not meant for production, so I didn&rsquo;t cover too much the error handling, the user feedback when the app is loading, or the testing.<br/>
You can find all the sources here:</p>

<p><a href="https://github.com/FancyPixel/small-rails">Rails API</a></p>

<p><a href="https://github.com/FancyPixel/small-frontend">React + Flux frontend</a></p>

<h2>Flux vs. Fluxxor vs. Reflux vs&hellip;</h2>

<p>Flux is not the only implementation of this architecture, you can find several libraries that do so, some of them are tied to React, some of them aren&rsquo;t, some of them don&rsquo;t even use the whole architecture. It&rsquo;s just a matter of preferences, you can checkout <a href="https://github.com/kriasoft/react-starter-kit/issues/22">this discussion</a> on GitHub for more info. Personally I chose <em>vanilla</em> flux to have a better understanding of all the underlying components, once you figure that out, there&rsquo;s always time to trim out the fat.</p>

<h1>The future of React</h1>

<p>While I was writing this the React.js conf took place, you can find a summary of what they announced <a href="http://kevinold.com/2015/01/31/takeaways-from-reactjs-conf-2015.html">here</a>. The most exciting thing was probably React native. Being an iOS developer at the core I always frowned upon web frameworks with native capabilities like Phonegap or Rubymotion, but if you take a look at <a href="https://www.youtube.com/watch?v=7rDsRXj9-cU">this presentation</a> it&rsquo;s hard not to be excited about React native. The thing that strikes me the most is that they nailed the core concept: forget &ldquo;<em>Write once run anywhere</em>&rdquo;, embrace &ldquo;<em>Learn once, write anywhere</em>&rdquo;.<br/>
React is here to stay, and it&rsquo;s already influencing every other JS framework around. I&rsquo;m excited to build future application with it and see how it&rsquo;s going to expand in the future.</p>

<p>Until next time</p>

<p><em>Andrea - <a href="https://twitter.com/theandreamazz">@theandreamazz</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React + Flux backed by Rails API - Part 2]]></title>
    <link href="http://fancypixel.github.io/blog/2015/01/29/react-plus-flux-backed-by-rails-api-part-2/"/>
    <updated>2015-01-29T10:31:00+01:00</updated>
    <id>http://fancypixel.github.io/blog/2015/01/29/react-plus-flux-backed-by-rails-api-part-2</id>
    <content type="html"><![CDATA[<p>This is the second part of &ldquo;React + Flux backed by Rails API&rdquo;, make sure to checkout <a href="http://fancypixel.github.io/blog/2015/01/28/react-plus-flux-backed-by-rails-api/">Part 1</a>.</p>

<p>In part 1 we created our fancy Rails API, setup the authentication and defined a resource for our tiny clone of Medium.
Time to reach the core of this post: the frontend built in React with the flux architecture.</p>

<!-- More -->


<h1>Setting up the frontend</h1>

<p>The whole idea behind splitting the backend from the fronted is to treat the web UI as a first class citizen, sitting in its own folder, in its own repo, with no bindings to the backend. The backend can be easily interchanged, as long as the API specs remain consistent. So we&rsquo;ll create a new app from scratch. We have the option to use automated tools like Yeoman, but I wasn&rsquo;t able to find the solution that fit all my needs.</p>

<h2>Tools</h2>

<p>I&rsquo;ll be using node&rsquo;s NPM to fetch the main tools, Gulp for the build and watch tasks, and Bower for the resources.
Before diving in the details, I have to warn you, I&rsquo;m awful with gulp, so I pretty much gathered tasks around the web. So take my gulp file lightly, I&rsquo;m planning on fixing all the horrors as soon as I can. You might also notice that I didn&rsquo;t use ES6, although I wanted to. I encountered in a couple of issues while working with ES6, so being time in short supply, I switched to vanilla Javascript.<br/>
You&rsquo;ll find the package.json and gulpfile.js in the <a href="https://github.com/FancyPixel/small-frontend">sample repo</a>, to make a long story short we&rsquo;ll be using <code>react</code> (obviously), <code>react-router</code>, <code>superagent</code> for the ajax calls and <code>flux</code>.
As I said before, Flux is just an architecture, so what am I importing really in my package.json? Turns out that Facebook released a small library called <code>flux</code> that contains basically the code for a Flux Dispatcher (more on that later), that will cut down the amount of boilerplate code that we&rsquo;ll need to get started.</p>

<h2>Flux Architecture</h2>

<p>If you already took a stab at Flux you might know this diagram:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2015-01-29/flux.png" width="640" height="320" title="'Flux architecture'" ></p>

<p>It might not be easy to understand at first, but it makes more and more sense while you are implementing all those coloured blocks. Let me shed some light over it if I can.</p>

<p>The leftmost block is our Web API, we built that in the previous part of this blog post, so we are set. Our API will be called by the &ldquo;Web API Utils&rdquo;, that&rsquo;s just a plain JS file making ajax requests. Eventually this JS component will receive an AJAX callback, and it&rsquo;ll need to update our frontend app. It does that using Actions. An action is just a data structure that tells the system what happened and what payload is associated with that action. <br/>
There are two types of actions: the one initiated by a server (e.g.: an AJAX callback) and those initiated by the views (e.g.: the user clicks a button). The difference between the two is basically semantics.<br/>
The actions are created through Action Creators, that are really just utility functions that build the action and toss it to the system, or to be more precise, the dispatcher.<br/>
The dispatcher is a single object (one per app) that, as the name suggests, dispatches actions to those who registered interest in them. Look at it as a pub-sub mechanism, plain and simple.
The objects that register interest in this actions are called Stores. Stores contain the application logic and state. They are similar to a model, but they manage the state of all the objects, not a single record.
Stores are the one offering the state that will be presented by the React views. React views should hold as few state as possible, they should grab the state of the data from a store, and pass the state to their children as props.</p>

<p>That&rsquo;s it really, it seems rather convoluted at first, but an example can clear the fog, let&rsquo;s consider the login process:</p>

<ul>
<li>The user enters his username and password, and clicks Login</li>
<li>The React view handles the click event, grabs the content of the fields and creates an action through an action creator, with the tag <code>LOGIN_REQUEST</code> and a payload with the user&rsquo;s credentials</li>
<li>The Action creator creates the <code>LOGIN_REQUEST</code> action with its payload attached, and alerts the Dispatcher</li>
<li>The Action creator also calls the Web API utils, passing the payload</li>
<li>The Web API Utils perform the AJAX call</li>
<li>The Rails API responds authenticating the user, providing the JSON response</li>
<li>The Web API Utils receives the JSON and creates a new action, called <code>LOGIN_RESPONSE</code>, with the new JSON as payload.</li>
<li>The dispatcher is notified, and forwards the action to the store(s) that is(are) interested in a <code>LOGIN_RESPONSE</code> action</li>
<li>The store (e.g.: a SessionStore) gets notified and extracts the payload from the action</li>
<li>The store updates its state (username, auth token and login state set to true)</li>
<li>The store emits its changes</li>
<li>The React views are notified of the changes and can be refreshed</li>
<li>The React views can grab the state from the store, and if needed pass the state to their children</li>
</ul>


<p>And that&rsquo;s it. Looks like a lot of work for a simple login, but the secret sauce that makes Flux work is that this pattern can be applied to every action performed by the user or the server. It keeps the main components decoupled, it&rsquo;s easier to maintain, and best of all, everything is tidy, for once.</p>

<p>Ok, that was a mouthful, let&rsquo;s see some code.</p>

<h1>Project structure</h1>

<p>We&rsquo;ll start with the project structure.</p>

<pre><code>scripts
|-actions
|-components
  |-common
  |-session
  |-stories
|-constants
|-dispatcher
|-stores
|-utils
app.jsx
routes.jsx
</code></pre>

<p><code>app.jsx</code> will be our mounting point, it will render the app in our html template, nothing fancy:</p>

<pre><code class="js">// app.jsx
var React = require('react');
var router = require('./stores/RouteStore.react.jsx').getRouter();
window.React = React;

router.run(function (Handler, state) {
  React.render(&lt;Handler/&gt;, document.getElementById('content'));
});
</code></pre>

<p>That&rsquo;s our first taste of React and JSX. JSX is a JS extension that lets us write nodes with a syntax similar to XML. It&rsquo;s optional, but it cleans up the syntax and can be handled with ease by designers.</p>

<h2>Routes</h2>

<p><code>router.jsx</code> holds all of our routes that will be used to instantiate react-router:</p>

<pre><code class="js">// routes.jsx
var React = require('react');
var Router = require('react-router');
var Route = Router.Route;
var DefaultRoute = Router.DefaultRoute;

var SmallApp = require('./components/SmallApp.react.jsx');
var LoginPage = require('./components/session/LoginPage.react.jsx');
var StoriesPage = require('./components/stories/StoriesPage.react.jsx');
var StoryPage = require('./components/stories/StoryPage.react.jsx');
var StoryNew = require('./components/stories/StoryNew.react.jsx');
var SignupPage = require('./components/session/SignupPage.react.jsx');

module.exports = (
  &lt;Route name="app" path="/" handler={SmallApp}&gt;
    &lt;DefaultRoute handler={StoriesPage} /&gt;
    &lt;Route name="login" path="/login" handler={LoginPage}/&gt;
    &lt;Route name="signup" path="/signup" handler={SignupPage}/&gt;
    &lt;Route name="stories" path="/stories" handler={StoriesPage}/&gt;
    &lt;Route name="story" path="/stories/:storyId" handler={StoryPage} /&gt;
    &lt;Route name="new-story" path="/story/new" handler={StoryNew}/&gt;
  &lt;/Route&gt;
);
</code></pre>

<p>Routes are expressed in JSX syntax, we can specify a name (that will be used to perform transitions and to create links), an handler (the React component that will be mounted when the route is visited) and an optional path (that the user will see in his address bar). As you can see we can also mount routes inside another route in a RESTful way.</p>

<h2>Dispatcher</h2>

<p>The dispatcher is the core of the app, it&rsquo;s the central hub for our messages (actions). It&rsquo;s also a fairly easy component to implement, it&rsquo;s mostly just boilerplate code:</p>

<pre><code class="js">// ./dispatcher/SmallAppDispatcher.js
var SmallConstants = require('../constants/SmallConstants.js');
var Dispatcher = require('flux').Dispatcher;
var assign = require('object-assign');

var PayloadSources = SmallConstants.PayloadSources;

var SmallAppDispatcher = assign(new Dispatcher(), {

  handleServerAction: function(action) {
    var payload = {
      source: PayloadSources.SERVER_ACTION,
      action: action
    };
    this.dispatch(payload);
  },

  handleViewAction: function(action) {
    var payload = {
      source: PayloadSources.VIEW_ACTION,
      action: action
    };
    this.dispatch(payload);
  }
});

module.exports = SmallAppDispatcher;
</code></pre>

<p>We are basically defining two main methods that will be used to dispatch a message. We use two instead of one just for semantics: one will handle the dispatch of server-initiated action, the other one the view-initiated actions.<br/>
Before proceeding to the meat of the implementation we&rsquo;ll take a look at the Constants file:</p>

<pre><code class="js">// constants/SmallConstants.js
var keyMirror = require('keymirror');

var APIRoot = "http://localhost:3002";

module.exports = {

  APIEndpoints: {
    LOGIN:          APIRoot + "/v1/login",
    REGISTRATION:   APIRoot + "/v1/users",
    STORIES:        APIRoot + "/v1/stories"
  },

  PayloadSources: keyMirror({
    SERVER_ACTION: null,
    VIEW_ACTION: null
  }),

  ActionTypes: keyMirror({
    // Session
    LOGIN_REQUEST: null,
    LOGIN_RESPONSE: null,

    // Routes
    REDIRECT: null,

    LOAD_STORIES: null,
    RECEIVE_STORIES: null,
    LOAD_STORY: null,
    RECEIVE_STORY: null,
    CREATE_STORY: null,
    RECEIVE_CREATED_STORY: null
  })

};
</code></pre>

<p>This is an utility file that holds the constants that we&rsquo;ll use throughout the project, mainly the API endpoint and the types of action that we can perform in our app.
Now, let&rsquo;s talk about the authentication process.</p>

<h1>Authentication</h1>

<p>As explained in the Flux example above, the data flow will be initiated by the user, that will visit the login page, fill a form with his credentials and click on submit. We&rsquo;ll handle the submit as a <code>VIEW_ACTION</code>, this means that our view will call a method of our action creator for the session. Let&rsquo;s take a look at it:</p>

<pre><code class="js">// ./scripts/actions/SessionActionCreators.react.jsx
var SmallAppDispatcher = require('../dispatcher/SmallAppDispatcher.js');
var SmallConstants = require('../constants/SmallConstants.js');
var WebAPIUtils = require('../utils/WebAPIUtils.js');

var ActionTypes = SmallConstants.ActionTypes;

module.exports = {

  signup: function(email, password, passwordConfirmation) {
    SmallAppDispatcher.handleViewAction({
      type: ActionTypes.SIGNUP_REQUEST,
      email: email,
      password: password,
      passwordConfirmation: passwordConfirmation
    });
    WebAPIUtils.signup(email, password, passwordConfirmation);
  },

  login: function(email, password) {
    SmallAppDispatcher.handleViewAction({
      type: ActionTypes.LOGIN_REQUEST,
      email: email,
      password: password
    });
    WebAPIUtils.login(email, password);
  },

  logout: function() {
    SmallAppDispatcher.handleViewAction({
      type: ActionTypes.LOGOUT
    });
  }

};
</code></pre>

<p>This cover all the user-initiated actions in the context of the session. The login action creator as you can see creates a new ViewAction, attaching a payload with the user&rsquo;s email and password, and then calls the <code>WebAPIUtils.login</code> method. If other components registered their interest in receiving the <code>LOGIN_REQUEST</code> action, the dispatcher would deliver this action right now.<br/>
The login method of our WebAPIUtils class is this:</p>

<pre><code class="js">// ./scripts/utils/WebAPIUtils.js
var ServerActionCreators = require('../actions/ServerActionCreators.react.jsx');
var request = require('superagent');

module.exports = {

  login: function(email, password) {
    request.post('http://localhost:3002/v1/login')
      .send({ username: email, password: password, grant_type: 'password' })
      .set('Accept', 'application/json')
      .end(function(error, res){
        if (res) {
          if (res.error) {
            var errorMsgs = _getErrors(res);
            ServerActionCreators.receiveLogin(null, errorMsgs);
          } else {
            json = JSON.parse(res.text);
            ServerActionCreators.receiveLogin(json, null);
          }
        }
      });
  },
  // ...
};
</code></pre>

<p>A common pattern should start to be apparent right now: no class is directly modifying the state of another one, but they are just creating new actions. That&rsquo;s the Flux way of handling data in a nutshell.<br/>
To keep things tidy the actions for results of the login process are created in a separate action creator:</p>

<pre><code class="js">// ./scripts/actions/ServerActionCreators.react.jsx
var SmallAppDispatcher = require('../dispatcher/SmallAppDispatcher.js');
var SmallConstants = require('../constants/SmallConstants.js');

var ActionTypes = SmallConstants.ActionTypes;

module.exports = {

  receiveLogin: function(json, errors) {
    SmallAppDispatcher.handleServerAction({
      type: ActionTypes.LOGIN_RESPONSE,
      json: json,
      errors: errors
    });
  },

 // ... 
};
</code></pre>

<p>And this covers the server and view actions for the login process. Who handles the result though? Let&rsquo;s talk about stores.</p>

<h2>SessionStore</h2>

<p>Stores are like a mix between a model and a controller, they handle the data, the main state of the application, feeding the records to the views, while retrieving the data from a server. We are about to see the <code>SessionStore</code>, which keeps track of the current user (and holds his access token, used in the API calls) and listens for the <code>LOGIN_RESPONSE</code> action.</p>

<pre><code class="js">// ./scripts/stores/SessionStore.react.jsx
var SmallAppDispatcher = require('../dispatcher/SmallAppDispatcher.js');
var SmallConstants = require('../constants/SmallConstants.js');
var EventEmitter = require('events').EventEmitter;
var assign = require('object-assign');

var ActionTypes = SmallConstants.ActionTypes;
var CHANGE_EVENT = 'change';

// Load an access token from the session storage, you might want to implement
// a 'remember me' using localSgorage
var _accessToken = sessionStorage.getItem('accessToken')
var _email = sessionStorage.getItem('email')
var _errors = [];

var SessionStore = assign({}, EventEmitter.prototype, {

  emitChange: function() {
    this.emit(CHANGE_EVENT);
  },

  addChangeListener: function(callback) {
    this.on(CHANGE_EVENT, callback);
  },

  removeChangeListener: function(callback) {
    this.removeListener(CHANGE_EVENT, callback);
  },

  isLoggedIn: function() {
    return _accessToken ? true : false;    
  },

  getAccessToken: function() {
    return _accessToken;
  },

  getEmail: function() {
    return _email;
  },

  getErrors: function() {
    return _errors;
  }

});

SessionStore.dispatchToken = SmallAppDispatcher.register(function(payload) {
  var action = payload.action;

  switch(action.type) {

    case ActionTypes.LOGIN_RESPONSE:
      if (action.json &amp;&amp; action.json.access_token) {
        _accessToken = action.json.access_token;
        _email = action.json.email;
        // Token will always live in the session, so that the API can grab it with no hassle
        sessionStorage.setItem('accessToken', _accessToken);
        sessionStorage.setItem('email', _email);
      }
      if (action.errors) {
        _errors = action.errors;
      }
      SessionStore.emitChange();
      break;

    case ActionTypes.LOGOUT:
      _accessToken = null;
      _email = null;
      sessionStorage.removeItem('accessToken');
      sessionStorage.removeItem('email');
      SessionStore.emitChange();
      break;

    default:
  }

  return true;
});

module.exports = SessionStore;
</code></pre>

<p>That looks like a bunch of code, but most of it is boilerplate, the interesting part is in the <code>.register</code> function. When the store receives the <code>LOGIN_RESPONSE</code> action unpacks the payload and checks wether the login was successful or not. It then updates its state (that will be accessed by the public properties declared on top of the file) and notifies a change to whomever might be listening (that&rsquo;s why we import node&rsquo;s EventEmitter and merge the class with it).<br/>
Ok, we have the ability to send a view action, we receive the result and store it, cool, now we need to use this store somewhere and show some UI already.</p>

<h2>Application</h2>

<p>Having a store and a state brings up a tricky question: who should listen to its changes and who should use its state? Following the React philosophy we should find the component at the topmost of our view&rsquo;s tree, without bloating the component itself though. As far as session goes I think the best place is the root of our app. The root is the first component that is mounted by the routes, and if you take a look at our routes, that would be the component called <code>SmallApp</code>:</p>

<pre><code class="js">  // ./scripts/components/SmallApp.react.jsx
  var React = require('react');
  var RouteHandler = require('react-router').RouteHandler;
  var Header = require('../components/Header.react.jsx');
  var SessionStore = require('../stores/SessionStore.react.jsx');
  var RouteStore = require('../stores/RouteStore.react.jsx');

  function getStateFromStores() {
    return {
      isLoggedIn: SessionStore.isLoggedIn(),
      email: SessionStore.getEmail()
    };
  }

  var SmallApp = React.createClass({

    getInitialState: function() {
      return getStateFromStores();
    },

    componentDidMount: function() {
      SessionStore.addChangeListener(this._onChange);
    },

    componentWillUnmount: function() {
      SessionStore.removeChangeListener(this._onChange);
    },

    _onChange: function() {
      this.setState(getStateFromStores());
    },

    render: function() {
      return (
        &lt;div className="app"&gt;
          &lt;Header 
            isLoggedIn={this.state.isLoggedIn}
            email={this.state.email} /&gt;
          &lt;RouteHandler/&gt;
        &lt;/div&gt;
      );
    }

  });

  module.exports = SmallApp;
</code></pre>

<p>This is a really simple component that serves as the root layout. If you take a closer look at the render function you can see that it only renders a React component named <code>Header</code> and then mounts the content provided by the Router. The header has a couple of properties though (React <code>props</code> to be exact) and we fill them with the <code>SmallApp</code> state. Those props will be accessible within the <code>Header</code> component. The <code>SmallApp</code> state is obtained by querying the <code>SessionStore</code> in two ways:</p>

<ul>
<li>by the function <code>getInitialState</code>, fired when the component is initialized</li>
<li>by the <code>_onChange</code> function, called when the <code>Sessionstore</code> emits a new change.</li>
</ul>


<p>The latter behaviour is possible since the <code>SmallApp</code> component registered its callback in the function <code>componentDidMount</code>, that is fired, you guessed it, when the component is mounted in the page.</p>

<p>Small recap: the user initiates a view action, the WebAPIUtils calls the server, the server replies, a new action is raised, the dispatcher forwards it to the SessionStore, which updates its status and emits a change event, catched by the <code>SmallApp</code> component. The <code>SmallApp</code> component forwards its state to its child: the <code>Header</code> component. Wew! Let&rsquo;s close the circle by writing our Header:</p>

<pre><code class="js">// ./scripts/components/Header.react.jsx
var React = require('react');
var Router = require('react-router');
var Link = Router.Link;
var ReactPropTypes = React.PropTypes;
var SessionActionCreators = require('../actions/SessionActionCreators.react.jsx');

var Header = React.createClass({

  propTypes: {
    isLoggedIn: ReactPropTypes.bool,
    email: ReactPropTypes.string
  },
  logout: function(e) {
    e.preventDefault();
    SessionActionCreators.logout();
  },
  render: function() {
    var rightNav = this.props.isLoggedIn ? (
      &lt;ul className="right"&gt;
        &lt;li className="has-dropdown"&gt;
          &lt;a href="#"&gt;{this.props.email}&lt;/a&gt;
          &lt;ul className="dropdown"&gt;
            &lt;li&gt;&lt;a href='#' onClick={this.logout}&gt;Logout&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt; 
      &lt;/ul&gt;
    ) : (
      &lt;ul className="right"&gt;
        &lt;li&gt;&lt;Link to="login"&gt;Login&lt;/Link&gt;&lt;/li&gt;
        &lt;li&gt;&lt;Link to="signup"&gt;Sign up&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
    );

    var leftNav = this.props.isLoggedIn ? (
      &lt;ul className="left"&gt;
        &lt;li&gt;&lt;Link to="new-story"&gt;New story&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
    ) : (
      &lt;div&gt;&lt;/div&gt;
    );

    return (
      &lt;nav className="top-bar" data-topbar role="navigation"&gt;
        &lt;ul className="title-area"&gt;
          &lt;li className="name"&gt;
            &lt;h1&gt;&lt;a href="#"&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/a&gt;&lt;/h1&gt;
          &lt;/li&gt;
          &lt;li className="toggle-topbar menu-icon"&gt;&lt;a href="#"&gt;&lt;span&gt;Menu&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;

        &lt;section className="top-bar-section"&gt;
          {rightNav}
          {leftNav}
        &lt;/section&gt;
      &lt;/nav&gt;
    );
  }
});

module.exports = Header;
</code></pre>

<p>As you can see we are finally defining our markup. Within this markup you might notice a couple of calls within curly braces, that references <code>this.props</code>. This object is filled with the properties declared in the previous component, so that&rsquo;s how a parent can forward informations down the chain of its child components. No more two way bindings, the data just flows from the root to the leaves. Also, React offers the ability to validate the props, by specifying the <code>propTypes</code>. Whenever we pass a prop to a component, React checks the data type, and raises a JS warning in the inspector&rsquo;s console. That&rsquo;s a handy debugging tool that improves the reusability of a single component.<br/>
It&rsquo;s apparent how we are defining our views in a declarative way. Once defined we are not handling the state with a barrage of spaghetti jQuery calls, we keep in mind that the view will get refreshed down the line.</p>

<p>It does look convolute at first, right? The Flux architecture becomes awesome once you realise that <em>every</em> interaction follows the same principle, then everything clicks in your brain. Noticed the <code>logout</code> function in the Header? It doesn&rsquo;t make a reference to the SessionStore, the Header doesn&rsquo;t even know it exists, it just follows a pattern: &ldquo;<em>when something happens, create an action</em>&rdquo;.<br/>
The code is decoupled, the responsabilities are separated, we can achieve modularity and reusability. For real this time. Brilliant.</p>

<h2>LoginPage</h2>

<p>We covered the server action, but we still need to let the user perform the login action. Let&rsquo;s fix that. You might have guessed it: we&rsquo;ll create a React component that will fire and action when the user submits the form.</p>

<pre><code class="js">// ./scripts/component/session/LoginPage.react.jsx
var React = require('react');
var SessionActionCreators = require('../../actions/SessionActionCreators.react.jsx');
var SessionStore = require('../../stores/SessionStore.react.jsx');
var ErrorNotice = require('../../components/common/ErrorNotice.react.jsx');

var LoginPage = React.createClass({
  getInitialState: function() {
    return { errors: [] };
  },

  componentDidMount: function() {
    SessionStore.addChangeListener(this._onChange);
  },

  componentWillUnmount: function() {
    SessionStore.removeChangeListener(this._onChange);
  },

  _onChange: function() {
    this.setState({ errors: SessionStore.getErrors() });
  },

  _onSubmit: function(e) {
    e.preventDefault();
    this.setState({ errors: [] });
    var email = this.refs.email.getDOMNode().value;
    var password = this.refs.password.getDOMNode().value;
    SessionActionCreators.login(email, password);
  },

  render: function() {
    var errors = (this.state.errors.length &gt; 0) ? &lt;ErrorNotice errors={this.state.errors}/&gt; : &lt;div&gt;&lt;/div&gt;;
    return (
      &lt;div&gt;
        {errors}
        &lt;div className="row"&gt;
          &lt;div className="card card--login small-10 medium-6 large-4 columns small-centered"&gt;
            &lt;form onSubmit={this._onSubmit}&gt;
              &lt;div className="card--login__field"&gt;
                &lt;label name="email"&gt;Email&lt;/label&gt;
                &lt;input type="text" name="email" ref="email" /&gt; 
              &lt;/div&gt;
              &lt;div className="card--login__field"&gt;
                &lt;label name="password"&gt;Password&lt;/label&gt;
                &lt;input type="password" name="password" ref="password" /&gt;
              &lt;/div&gt;
              &lt;button type="submit" className="card--login__submit"&gt;Login&lt;/button&gt;
            &lt;/form&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

module.exports = LoginPage;
</code></pre>

<p>As you can see we have our boilerplate declaration of the change callback at the start of the file, that&rsquo;s pretty common. You might also notice that this component has its own state, unlike the Header. This is because I felt that the login error (retrieved by the SessionStore) belongs in the page itself, since it&rsquo;ll be rendered there, and there&rsquo;s no need to let it have a broader scope by integrating it as a state in the main <code>SmallApp</code> component.<br/>
Getting back to the login process, the render function defines the markup of our login form, and on submit the component will retrieve email and password, and create a new action with them. That&rsquo;s it.</p>

<h1>Next up</h1>

<p>It might be a good time to take another break, in the next part we&rsquo;ll go through listing and posting a new story in our app, and then it&rsquo;s conclusions time. I&rsquo;ll see you soon.</p>

<p><a href="http://fancypixel.github.io/blog/2015/01/30/react-plus-flux-backed-by-rails-api-part-3/">Part 3</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React + Flux backed by Rails API - Part 1]]></title>
    <link href="http://fancypixel.github.io/blog/2015/01/28/react-plus-flux-backed-by-rails-api/"/>
    <updated>2015-01-28T16:04:00+01:00</updated>
    <id>http://fancypixel.github.io/blog/2015/01/28/react-plus-flux-backed-by-rails-api</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been working on a frontend for a project we are developing here at Fancy Pixel. We are embracing what looks like a good habit: slicing what would be a monolithic Rails app in a lightweight backend serving APIs and a frontend consuming them. We did this in the not so distant past using Angular.js. It was all fine and dandy, until it wasn&rsquo;t. There&rsquo;s something about it that doesn&rsquo;t sit right with me, I wouldn&rsquo;t go in detail, since many others already did, but let&rsquo;s just say that there&rsquo;s too much magic involved for my tastes (says the guy using Rails). Magic is fine as long as I can figure out how to tinker with the internals when things go down south. With Angular the effort seems too much, but that&rsquo;s just personal taste really. Also I can&rsquo;t deny that the major structural changes introduced in 2.0 were the last nail in the coffin.<br/>
I wanted to try something new, something that would enforce a solid architecture of our apps, letting me control the single cogs in the engine. React got a lot of good press in the past months, so I took the chance to dive in. In this three-part post you&rsquo;ll find pretty much everything I learned by writing a frontend using React, with a vanilla Flux architecture, consuming an API written in Rails.</p>

<!-- More -->


<h2>Choosing the backend</h2>

<p>Given our experience, the obvious choice for us was Rails, but with a twist: <a href="https://github.com/rails-api/rails-api">rails-api</a>. Rails-api is a stripped down version of Rails, where most of the &lsquo;<em>useless</em>&rsquo; middleware is not included (but you can include it might you need it). Using Rails to serve JSON might seem overkill to most, but the Github page of rails-api has some really good points to counter this argument, and I think they are spot on.
TL;DR version: Rails is awesome, let&rsquo;s take advantage of that.</p>

<h2>The frontend technology</h2>

<p>React is javascript library for building user interfaces built and open sourced by the Facebook&rsquo;s engineers. Its major selling point is the ability to provide a dynamic and fast way to build isomorphic apps.<br/>
Isomorphic means that the app can be rendered with ease on both the server and the client, which helps with SEO.<br/>
Personally, I couldn&rsquo;t care less about SEO, even if I understand how important it is&hellip; I was really sold on React by the Virtual DOM and how the data is organized and handled in React views.
The Virtual DOM is something that we&rsquo;re going to see implemented in other JS frameworks (Ember does that already if I&rsquo;m not mistaken). The views can be rendered on the server for the initial request, than the underlying tech is going to render subsequent pages in a Virtual DOM, that is then diffed with the actual DOM, and then only the differences are changes in the visible page. And it&rsquo;s fast. Brilliant. This enables us to start writing frontend like we used way back: in a declarative way&hellip; we just specify how the UI should look, when data changes React takes care of the page refresh, changing only the parts that need to be changed.</p>

<h2>Flux</h2>

<p>This covers the backend and the views, we&rsquo;re missing something in between, say, an architecture to follow. Flux is an architecture for building web UIs, and works really well in combination with React (but it can really be applied anywhere).</p>

<h2>Here comes trouble</h2>

<p>I never was a big fan of implementing web UI, CSS always gets messy, Javascript files become scary monoliths where crappy code goes to die, while developers test their spelunker skills and loose their sanity. Maybe I&rsquo;m just crap, but even using Sass and Coffeescript never really solved my issues.<br/>
I was excited to try something really new, but I knew that getting started with such a young technology would end up being a major pain in the ass. <br/>
Case and point, learning and starting being productive (i.e.: writing usable code) took a fair bit of head scratching. There&rsquo;s still no clear &ldquo;best practice&rdquo; to perform common tasks, nor a clear starting configuration. Let&rsquo;s put it that way, if you come from the RoR world, where convention over configuration greatly reduces boilerplating and &ldquo;forces&rdquo; you to follow commonly established best practice, you&rsquo;re going to struggle with Flux.
This post will cover the solutions we came up with, they may not be perfect, but I&rsquo;m fairly sure there are no anti-patterns in there, and they are a solid starting point.</p>

<h1>Getting it all toghether</h1>

<p>Let&rsquo;s start writing some code. We&rsquo;ll go through a simple Rails app that will feature user signup and login, and the ability to post a story. Just like a tiny Medium. Let&rsquo;s appropriately call it <em>Small</em>.</p>

<p>Feel free to skip the Railsy part if you&rsquo;re only interested in Flux and React and jump to <a href="http://fancypixel.github.io/blog/2015/01/29/react-plus-flux-backed-by-rails-api-part-2/">Part 2</a>.</p>

<h1>Rails API</h1>

<p>A while ago I stumbled upon <a href="http://slides.com/alanpeabody/breaking-up-with-the-asset-pipeline#/">this article</a> by Alan Peabody. I had a similar experience as him, you start working ona project, you use the right tools, you do your best to enforce good patterns, but in the end the frontend code just becomes scary, something no one wants to maintain. Let&rsquo;s break up with the asset pipeline, as the title says, and work towards making Rails beautiful again.
We&rsquo;ll be using the rails-api gem for this task. You can generate a new app with its CLI command, or you can integrate it later. I&rsquo;ll do the later option, no reason really, just a habit.</p>

<pre><code>rails new small
</code></pre>

<p>Next we&rsquo;ll add <code>rails-api</code>, <code>devise</code>, <code>active_model_serializers</code> gems to our Gemfile, and while we are at it we can remove all the gems that generate assets or view content, <code>jbuilder</code> included. Our Gemfile should look like this (test section omitted):</p>

<pre><code class="ruby">source 'https://rubygems.org'

gem 'rails', '4.2.0'
gem 'rails-api', '~&gt; 0.4.0'
gem 'active_model_serializers', '~&gt; 0.8.3' # NOTE: not the 0.9
gem 'devise', '~&gt; 3.4.1'
gem 'sqlite3'
gem 'sdoc', '~&gt; 0.4.0', group: :doc
gem 'thin'

group :development, :test do
  gem 'faker'
  gem 'byebug'
  gem 'web-console', '~&gt; 2.0'
  gem 'spring'
end
</code></pre>

<p>Now we need to change the application controller so that it inherits from <code>ActionController::API</code>, and kiss the <code>protect_from_forgery</code> goodbye. Since we are serving only JSON, it makes sense to add</p>

<pre><code class="ruby">respond_to :json
</code></pre>

<p>to the applciation controller, helps DRYing all out. While we are at it, we might as well delete the assets and views folders, we won&rsquo;t need them.</p>

<h2>Authentication</h2>

<p>Should I first define a resource? Maybe, but that&rsquo;s trivial, let&rsquo;s get the authentication out of the way. We are building an API, so no session will be involved, we have to authenticate the user in each request. I&rsquo;ll be using <a href="http://oauthlib.readthedocs.org/en/latest/oauth2/grants/password.html">Oauth2 Resource Owner Password Credentials Grant</a> which sounds fancy, but it&rsquo;s really just a token in the request header that authenticates the caller.<br/>
The gem Devise used to implement a <code>token_authenticatable</code> strategy, but it was pulled for security reason. There are gems that implement the strategy (like Doorkeeper), but since it&rsquo;s fairly easy to implement I&rsquo;ll do it for myself. Let&rsquo;s install Devise first by adding it in the Gemfile and launching <code>rails generate devise:install</code> after a <code>bundle install</code>, then we create the user model:</p>

<pre><code>rails generate devise User
</code></pre>

<h2>Token authentication</h2>

<p>Token authentication was removed from Devise a couple of years ago, <a href="http://blog.plataformatec.com.br/2013/08/devise-3-1-now-with-more-secure-defaults/">this link</a> explains why. We have to implement it for ourselves, but it&rsquo;s quite easy. The token will be composed of two informations: the user&rsquo;s id followed by the token itself, separated by a <code>:</code>. We&rsquo;ll be using the user&rsquo;s database id for this sample, for semplicity&rsquo;s sake, but it&rsquo;s obviously not a smart thing to do.
First things first, we&rsquo;ll add an <code>access_token</code> to the user (and a username too):</p>

<pre><code class="ruby">class AddAccessTokenToUser &lt; ActiveRecord::Migration
  def change
    add_column :users, :access_token, :string
    add_column :users, :username, :string
  end
end
</code></pre>

<p>and here&rsquo;s the User model:</p>

<pre><code class="ruby"># app/models/user.rb
class User &lt; ActiveRecord::Base
  devise :database_authenticatable, :recoverable, :validatable

  after_create :update_access_token!  

  validates :username, presence: true
  validates :email, presence: true

  private

  def update_access_token!
    self.access_token = "#{self.id}:#{Devise.friendly_token}"
    save
  end

end
</code></pre>

<p>The user authentication will sit in the application controller:</p>

<pre><code class="ruby"># app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include AbstractController::Translation

  before_action :authenticate_user_from_token!

  respond_to :json

  ## 
  # User Authentication
  # Authenticates the user with OAuth2 Resource Owner Password Credentials Grant
  def authenticate_user_from_token!
    auth_token = request.headers['Authorization']

    if auth_token
      authenticate_with_auth_token auth_token
    else
      authentication_error
    end
  end

  private

  def authenticate_with_auth_token auth_token 
    unless auth_token.include?(':')
      authentication_error
      return
    end

    user_id = auth_token.split(':').first
    user = User.where(id: user_id).first

    if user &amp;&amp; Devise.secure_compare(user.access_token, auth_token)
      # User can access
      sign_in user, store: false
    else
      authentication_error
    end
  end

  ## 
  # Authentication Failure
  # Renders a 401 error
  def authentication_error
    # User's token is either invalid or not in the right format
    render json: {error: t('unauthorized')}, status: 401  # Authentication timeout
  end
end
</code></pre>

<p>We conclude the auth process by providing the routes and the session controller:</p>

<pre><code class="ruby"># config/routes.rb
Rails.application.routes.draw do
  devise_for :user, only: []

  namespace :v1, defaults: { format: :json } do
    resource :login, only: [:create], controller: :sessions
  end
end
</code></pre>

<p>and the session controller:</p>

<pre><code class="ruby"># app/controllers/v1/sessions_controller.rb
module V1
  class SessionsController &lt; ApplicationController
    skip_before_action :authenticate_user_from_token!

    # POST /v1/login
    def create
      @user = User.find_for_database_authentication(email: params[:username])
      return invalid_login_attempt unless @user

      if @user.valid_password?(params[:password])
        sign_in :user, @user
        render json: @user, serializer: SessionSerializer, root: nil
      else
        invalid_login_attempt
      end
    end

    private

    def invalid_login_attempt
      warden.custom_failure!
      render json: {error: t('sessions_controller.invalid_login_attempt')}, status: :unprocessable_entity
    end

  end
end
</code></pre>

<p>The SessionSerializer is an Active Model Serializer object, something like this:</p>

<pre><code class="ruby"># app/serializers/v1/session_serializer.rb
module V1
  class SessionSerializer &lt; ActiveModel::Serializer

    attributes :email, :token_type, :user_id, :access_token

    def user_id
      object.id
    end

    def token_type
      'Bearer'
    end

  end
end
</code></pre>

<p>That&rsquo;s it. Migrate, run the server, and create a user via the console. You should get something like this:</p>

<pre><code>$ curl localhost:3000/v1/login --ipv4 --data "usernme=user@example.com&amp;password=password"
{
  "token_type": "Bearer",
  "user_id": 1,
  "access_token": "1:MPSMSopcQQWr-LnVUySs"
}
</code></pre>

<h2>Creating a resource</h2>

<p>I won&rsquo;t go in detail here, the task is just plain RoR. We&rsquo;ll create a Story resource and a controller that will handle the user creation. You&rsquo;ll find the complete rails app in <a href="https://github.com/FancyPixel/small-rails">this repo</a>. Moving on.</p>

<h2>CORS</h2>

<p>It&rsquo;s worth noting that the UI now will not be served by rails, it might even sit in a different server. There are solution that let us keep both UI and API on the same domain, but for now we will need to enable Cross-origin resource sharing (<a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>). We can do this by adding the <a href="https://github.com/cyu/rack-cors">rack-cors gem</a> to our Gemfile and then add this in our <code>config/application.rb</code>:</p>

<pre><code class="ruby">config.middleware.insert_before 'Rack::Runtime', 'Rack::Cors' do
  allow do
    origins '*'
    resource '*',
             headers: :any,
             methods: [:get, :put, :post, :patch, :delete, :options]
  end
end
</code></pre>

<p>This opens up to every domain, so thread lightly.</p>

<h2>Next up</h2>

<p>That&rsquo;s it for the Rails part. It&rsquo;s such a joy writing just the API in Rails. It&rsquo;s easier to test, easier to maintain and it&rsquo;s blazing fast. Now we&rsquo;ll proceed with the frontend.
For readability&rsquo;s sake I&rsquo;ll split the article here, jump to Part 2 to start building the frontend.</p>

<p><a href="http://fancypixel.github.io/blog/2015/01/29/react-plus-flux-backed-by-rails-api-part-2/">Part 2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fun with iBeacon]]></title>
    <link href="http://fancypixel.github.io/blog/2014/07/01/fun-with-ibeacon/"/>
    <updated>2014-07-01T20:47:00+02:00</updated>
    <id>http://fancypixel.github.io/blog/2014/07/01/fun-with-ibeacon</id>
    <content type="html"><![CDATA[<p>You probably know already what <a href="https://developer.apple.com/library/ios/documentation/userexperience/conceptual/LocationAwarenessPG/RegionMonitoring/RegionMonitoring.html">iBeacon</a> is, but just to reiterate, iBeacon is the Apple way of saying Bluetooth 4 Low Energy. At the cost of sounding like a mindless drone, by &lsquo;the Apple way of&rsquo; I mean &lsquo;it just works and shows a lot of potential&rsquo;. An iBeacon is a simple B4LE device that keeps broadcasting its presence. Other B4LE devices can sense when they reach the beacon without draining the battery (hence the LE) and making the user scream in agony. &ldquo;Oook, what do I do with it?&rdquo;. The best thing you can do is locating a user without the GPS, which means locating a user inside a building. The cool thing is that it&rsquo;s fast, it takes seconds to detect a beacon and to react to its vicinity (or lack there of), and it works within the reach of Bluetooth technology (let&rsquo;s say around a 50 meters radius). I should also mention that it works fine with Android too.</p>

<p>This week an <a href="http://estimote.com">Estimote</a> developer kit arrived in our offices, so we took the chance to play around with it.</p>

<!-- More -->


<p>I already tried my hand with iBeacons in the not so distant past. Using <a href="https://github.com/lgaches/BeaconEmitter">BeaconEmitter</a> you can easily turn your Mac into a beacon, with no extra hardware required. When I experimented with iBeacons I had a couple of ideas on my mind, that involved being able to send a local notification to the user that enters in range of a device acting as a beacon. My dreams were crushed by the limits of the iOS 7.0 implementation, as I found out that:</p>

<ul>
<li>you can&rsquo;t react when the user&rsquo;s screen is turned off</li>
<li>you can&rsquo;t perform any action when your app is in background, even if you request the <code>location</code> background state</li>
<li>detecting when the user leaves a region takes quite a lot of time (at least 10/15 minutes)</li>
</ul>


<p>The most exciting thing about playing around with the Estimote SDK, besides the nifty packaging and well designed piece of hardware, is that my devices now have iOS 7.1. It turns out that with version 7.1, iOS is way more flexible and it&rsquo;s taking care of all the problems I faced with 7.0:</p>

<ul>
<li>you can show a local notification when the screen is off</li>
<li>you can perform operations when the user enters a region (even if the app was killed)</li>
<li>it takes second to detect when the user is out of range</li>
</ul>


<p>This turns everything around, iBeacons aren&rsquo;t just a gimmick now, but an exciting tool to experiment with.</p>

<h2>Building a sample</h2>

<p>First thing that came to our mind was to build a simple system to automatically check people in and out of the office. Really, as simple as it gets, it took a couple of hours to build, but it works surprisingly well.</p>

<h3>Rails backend</h3>

<p>To check people in and out we need a backend and an authentication system. Rails makes it easy, a model, a basic API and the help of Devise for the authentication process.</p>

<pre><code class="ruby"># app/model/checkin.rb lang:ruby
class Checkin &lt; ActiveRecord::Base

  belongs_to :user  
  enum direction: { in: 0, out: 1 }

end
</code></pre>

<p>That&rsquo;s a pretty basic model, taking advantage of Rails 4.1 enums.</p>

<p>The routes are scoped as APIs, just to be fancy:</p>

<pre><code class="ruby"># config/routes.rb
namespace :api, defaults: {format: :json} do
  namespace :v1 do
    post 'checkin', to: 'checkins#checkin'
    post 'checkout', to: 'checkins#checkout'
  end
end
</code></pre>

<p>And the controller does pretty much just this:</p>

<pre><code class="ruby"># checkins_controller.rb
def checkin
  checkin = Checkin.new(user: current_user, direction: :in)
  if checkin.save
    head :no_content
  else
    render json: {errors: checkin.errors}, status: :unprocessable_entity
  end
end
</code></pre>

<p>The authentication is handled by Devise, and for simplicity we opted for HTTP Basic Authentication.</p>

<h3>iOS Client</h3>

<p>The iOS app needs to look for our trusty beacon, and once the user is in range of our region, it needs to make a POST call to our API. When the user walks out of the office the phone needs to do the same to the checkout API. The iOS APIs for handling beacons are inside CoreLocation, in this sample I&rsquo;ll be using two main delegate methods:</p>

<pre><code class="objectivec">- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region;
- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region;
</code></pre>

<p>The good guy calling these two methods is a <code>CLLocationManager</code> instance. The location manager needs an instance of <code>CLBeaconRegion</code> to start doing its magic though. We can define a region by specifying a UUDID, an identifier, a major and a minor. It might sound confusing at first, but all those things boil down to this:</p>

<ul>
<li><code>UUDID</code>: A unique identifier of our beacon network. It&rsquo;s best practice to have one UUDID per App. Each beacon will share the same UUDID.</li>
<li><code>identifier</code>: It&rsquo;s a string representation of our network. It usually is the reverse URI of our App, something along the line of com.something.awesome.</li>
<li><code>major</code>: It&rsquo;s an integer that specifies the major group of our beacons. Think of it as a common number that can identify a bunch of beacons inside a building.</li>
<li><code>minor</code>: It&rsquo;s an integer that specifies the single beacon inside of a major group.</li>
</ul>


<p>So our basic config would be one UUDID and identifier per App, one major per building, and one minor per beacon. For the purposes of this sample we only have a beacon, so we can either disregard this info, or just specify whatever major and minor that we want, as long as it matches the ones configured in the beacon itself.
Now that all that is out of the way, let&rsquo;s get to the code:</p>

<pre><code class="objectivec">- (CLBeaconRegion *)region
{
    if (_region == nil) {
        NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:self.settings[@"udid"]];
        _region = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID
                                                          major:[self.settings[@"major"] intValue]
                                                          minor:[self.settings[@"minor"] intValue]
                                                     identifier:self.settings[@"identifier"]];

        [_region setNotifyOnExit:YES];
        [_region setNotifyOnEntry:YES];
        [_region setNotifyEntryStateOnDisplay:YES];
    }
    return _region;
}
</code></pre>

<p>There we go, our lazy loaded region that reads the parameters from an NSDictionary. Cool, let&rsquo;s start monitoring:</p>

<pre><code class="objectivec">[self.manager startMonitoringForRegion:self.region];
[self.manager stopRangingBeaconsInRegion:self.region];  
</code></pre>

<p>The first line is pretty self explanatory, the second one just tells the system that I don&rsquo;t really care for the single beacons, I just need the region updates.</p>

<p>Now that we are monitoring the region, we just need to decide what to do when we are in and out of range:</p>

<pre><code class="objectivec">- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region
{
    if ([region isKindOfClass:[CLBeaconRegion class]]) {
        CLBeaconRegion *beaconRegion = (CLBeaconRegion *)region;
        if ([beaconRegion.identifier isEqualToString:self.settings[@"identifier"]] &amp;&amp; [beaconRegion.major intValue] == [self.settings[@"major"] intValue] &amp;&amp; [beaconRegion.minor intValue]== [self.settings[@"minor"] intValue]) {
            UILocalNotification *notification = [[UILocalNotification alloc] init];
            notification.userInfo = @{@"identifier": region.identifier};
            notification.alertBody = [NSString stringWithFormat:@"Entering %@", region.identifier];
            notification.soundName = @"Default";
            [[UIApplication sharedApplication] presentLocalNotificationNow:notification];
            [self remoteCheckin:FPCheckDirectionIn];
        }
    }
}

- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region
{
    if ([region isKindOfClass:[CLBeaconRegion class]]) {
        CLBeaconRegion *beaconRegion = (CLBeaconRegion *)region;
        if ([beaconRegion.identifier isEqualToString:self.settings[@"identifier"]] &amp;&amp; [beaconRegion.major intValue] == [self.settings[@"major"] intValue] &amp;&amp; [beaconRegion.minor intValue]== [self.settings[@"minor"] intValue]) {
            UILocalNotification *notification = [[UILocalNotification alloc] init];
            notification.userInfo = @{@"identifier": region.identifier};
            notification.alertBody = [NSString stringWithFormat:@"Exiting %@", region.identifier];
            notification.soundName = @"Default";
            [[UIApplication sharedApplication] presentLocalNotificationNow:notification];
            [self remoteCheckin:FPCheckDirectionOut];
        }
    }
}
</code></pre>

<p>As you can see, we&rsquo;re just checking against our beacon, when we are in range or when we get out of range, we push a local notification and we perform a remote call to our Rails backend. You can find the full source on our Github account, don&rsquo;t worry.</p>

<h2>Who&rsquo;s Fancy?</h2>

<p>And there we go, the iOS app:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2014-07-01/iOS.png" title="'Who's Fancy iOS'" ></p>

<p>and the web page:</p>

<p><img class="center" src="http://fancypixel.github.io/images/posts/2014-07-01/rails.png" title="'Who's Fancy Rails'" ></p>

<p>You can find the rails and iOS code <a href="https://github.com/FancyPixel/whosfancy-rails">here</a> and <a href="https://github.com/FancyPixel/whosfancy-ios">here</a>.</p>

<h4>Android version</h4>

<p>We also pushed the Android version on our Github page, you can find it <a href="https://github.com/FancyPixel/whosfancy-android">here</a>.</p>

<p>Until next time.</p>

<p>Andrea</p>
]]></content>
  </entry>
  
</feed>
